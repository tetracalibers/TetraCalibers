["アルゴリズムとデータ構造 tomixy since 2021/11/5 目次 第 I 部 アルゴリズム 1 1 アルゴリズムの図示 1 2 探索（サーチ）アルゴリズム 2 2.1 線形探索法 ..................................... 2 2.2 二分探索法 ..................................... 6 3 整列（ソート）アルゴリズム 9 3.1 値の交換 ...................................... 9 3.2 テストツール ................................... 10 3.2.1 JavaScript（Node.js）版 ........................ 10 3.2.2 Ruby 版 .................................. 12 3.3 基本交換法（バブルソート） .......................... 13 3.4 基本選択法（選択ソート） ............................ 14 3.5 基本挿入法（挿入ソート） ............................ 16 3.6 シェルソート ................................... 18 3.7 マージソート ................................... 20 3.8 クイックソート .................................. 22 3.9 ヒープソート ................................... 27 i ","目次 ii 第 II 部 データ構造 28 4 配列 28 4.1 概要 ......................................... 28 4.2 データの取得 ................................... 29 4.3 データの挿入 ................................... 29 4.4 データの削除 ................................... 31 5 連結リスト 32 5.1 単方向連結リスト ................................. 32 5.1.1 データの取得 ............................... 33 5.1.2 データの挿入 ............................... 35 5.1.3 データの削除 ............................... 36 5.2 双方向連結リスト ................................. 37 5.2.1 データの取得 ............................... 38 5.2.2 データの挿入 ............................... 40 5.2.3 データの削除 ............................... 41 5.3 循環（環状）リスト ................................ 42 6 スタック 42 7 キュー（待ち行列） 45 8 ハッシュ 48 9 木 48 9.1 2 分木 ........................................ 50 9.2 完全 2 分木 ..................................... 51 9.3 2 分探索木 ..................................... 52 9.3.1 データの探索 ............................... 54 9.3.2 データの挿入 ............................... 57 9.3.3 データの削除 ............................... 59 9.4 ヒープ ....................................... 61 9.5 AVL 木 ....................................... 68 ","1 第 I 部 アルゴリズム 1 アルゴリズムの図示 アルゴリズムをわかりやすく記述するために用いられるのが フローチャート （ 流れ図 ） であり、次のような記号を使って処理の流れを表す。 処理の開始と終了 処理　　　 条件分岐 繰り返しの開始 繰り返しの終了 また、変数の代入は次のように表す。 変数名 ← 代入する値 ","2 2 探索（サーチ）アルゴリズム 2.1 線形探索法 線形探索法 入力: 長さ n の配列 a[] とデータ x 出力: a[i]= x となる i が存在すれば i、存在しなければNo Existを表示 i ← 1; while i ≤ n&&a[i] ̸= x do i ← i +1; end if i ≤ n then print i; else print No Exist; end 線形探索法は、先頭から順に探索していく方法であり、 • データが見つかった • 配列の添字範囲を超えた のいずれかに該当すれば、探索終了となる。 ここで、 配列の中に目的のデータが必ず存在する 状況を作ると、添字の範囲内で必ず目的のデータが見つかるため、 「配列の添字範囲を超えたか？」の判定が不要になる。 ","2.1 線形探索法 3 配列の最後に目的のデータ（ 番兵 ）をくっつけることで、そんな状況を実現する。 ","2.1 線形探索法 4 番兵による線形探索法 入力: 長さ n の配列 a[] とデータ x 出力: a[i]= x となる i が存在すれば i、存在しなければNo Existを表示 i ← 1; a[n + 1] ← x; while a[i] ̸= x do i ← i +1; end if i<n +1 then print i; else print No Exist; end 目的のデータが先頭にあった場合、探索回数は最小となり、1 回で済む。 目的のデータがない（番兵だけが目的のデータである）場合、 1 番目のデータから n +1 番目の番兵まで全てを探索することになり、 その回数は (n + 1) − 1= n 回である。 探索回数の最小値が 1、最大値が n であることから、平均の探索回数 S は、 S = 1 n · n ∑ i=1 i = 1 n · n(n + 1) 2 = (n + 1) 2 ","2.1 線形探索法 5 となる。 まとめると、線形探索の計算量は、 • 最良の場合で 1 • 最悪の場合で n • 平均は n +1 2 • オーダー表記では O(n) となる。 ","2.2 二分探索法 6 2.2 二分探索法 二分探索法（昇順の場合） 入力: 長さ n の昇順（左から小さい順）にソートされた配列 a[] とデータ x 出力: a[i]= x となる i が存在すれば i、存在しなければNo Existを表示 left ← 1; right ← n; while left < right do center ← (left+right) 2 ; if x>a[center] then left ← center +1; else if x<a[center] then right ← center − 1; else print center; end end print No Exist; 二分探索法は、昇順または降順にソートされている時のみ利用できる方法で、 昇順の場合は次のような絞り込みを繰り返すことで、目的のデータ target を見つけ出す。 • target > a center なら、 a center より左に target があるため、前半を探索範囲から除く • target < a center なら、 a center より右に target があるため、後半を探索範囲から除く • target = a center なら、探索終了 ","2.2 二分探索法 7 不等号を逆転させることで、降順の場合にも対応できる。 ","2.2 二分探索法 8 二分探索法（降順の場合） 入力: 長さ n の降順（左から大きい順）にソートされた配列 a[] とデータ x 出力: a[i]= x となる i が存在すれば i、存在しなければNo Existを表示 left ← 1; right ← n; while left > right do center ← (left+right) 2 ; if x<a[center] then left ← center +1; else if x>a[center] then right ← center − 1; else print center; end end print No Exist; 二分探索法では、探索範囲を 1 2 に狭めながら探索していく。 よって、データ数が 2 倍 になるごとに探索回数が 1 回増えることになるので、 k 回 n が 2 倍になった時点の探索回数 S は k すなわち、 n =2 k = ⇒ S = k が成り立つ。 n =2 k は k = log 2 n と同値なので、これを S = k に代入して、 S = log 2 n ","9 これが平均探索回数となる。 最初から中央に目的のデータがあった場合、探索回数は最小となり、1 回で済む。 先頭もしくは最後尾に目的のデータがあった場合、探索回数は最大となる。 このとき、 • 最初の中央値を見るために 1 回 • 以降、探索範囲を 1 2 にしながら log 2 n 回 の探索を行う必要があるから、探索回数は log 2 n +1 回となる。 まとめると、線形探索の計算量は、 • 最良の場合で 1 • 最悪の場合で log 2 n +1 • 平均は log 2 n • オーダー表記では O(log 2 n) となる。 3 整列（ソート）アルゴリズム 整列アルゴリズムのサンプルコードは JavaScript（Node.js）で記述している。 3.1 値の交換 どんな言語にも備わっている最低限の機能だけを使うなら、2 値の交換は次のように行う ことになる。 2 値 a と b の交換アルゴリズム // 今の a の値を保存 var tmp = a ","3.2 テストツール 10 // a に b の値を代入（a と b が同じ値になる） a = b // 元の a の値を b に代入 b = tmp とはいえ、JavaScript では 2 値の交換（JavaScript 特有の記法） [a, b] = [b, a] と書けば済む話なので、今後はこの記法を用いる。 3.2 テストツール ソートアルゴリズムを試す際、テスト用にいちいち適当な配列を作成するのは意外と面倒 なので、自動化ツールを作成した。 3.2.1 JavaScript（Node.js）版 テスト用配列を作成するモジュール（Dice.js） function randomNumber(max) { return Math.round(Math.random() * max); } module.exports = function (max){ var array = []; while (array.length < max){ ","3.2 テストツール 11 var number = randomNumber(max); if (!array.includes(number) && number !== 0){ array.push(number); } } return array; } 上のモジュールは単体のファイルとして保存し、次のように使う。 各ソート関数を記述するファイル（Sort.js） // Dice モジュールを読み込む const randomArray = require('Dice.js ファイルのパス'); // ソート関数を定義 // ソート関数をテスト var a = randomArray(配列の要素数); console.log(ソート関数名 (a)); 配列の要素数は任意だが、randomArray 関数は高速化に全くこだわっていないため、100 以下を推奨。 テストを実行する際には、次のコマンドを実行する。 $> cd ファイルがあるディレクトリ $> node Sort.js ","3.2 テストツール 12 言うまでもないが、node コマンドを使えるようにしておく必要がある。 3.2.2 Ruby 版 テスト用配列を作成するモジュール（Dice.rb） class Dice def initialize(max) @max = max end def number return rand(1..@max) end def array array = [] while array.length < @max number = self.number if !array.include?(number) array.push(number) end end return array end end 上のモジュールは単体のファイルとして保存し、次のように使う。 ","3.3 基本交換法（バブルソート） 13 各ソート関数を記述するファイル（Sort.rb） # Dice モジュールを読み込む require './Dice' # ソート関数を定義 # ソート関数をテスト random = Dice.new( 配列の要素数) a = random.array p ソート関数名(a) 配列の要素数は任意だが、randomArray 関数は高速化に全くこだわっていないため、100 以下を推奨。 テストを実行する際には、次のコマンドを実行する。 $> cd ファイルがあるディレクトリ $> ruby Sort.rb 3.3 基本交換法（バブルソート） 基本交換法（バブルソート）は、 1. 隣接するデータの大小を比較 2. 必要に応じて入れ替える という操作を繰り返すことにより、全体を整列させる方法である。 隣り合った 2 つの要素を a[i] と a[j ] で表し、そのうち前にある方を a[i] とする。 配列の要素数を n とすると、i、j はそれぞれ • a[i] は前の要素であるから、最後に 1 つ分余白を空けて、0 ≤ i ≤ n − 1 ","3.4 基本選択法（選択ソート） 14 • a[j ] は後の要素であるから、先頭に 1 つ分余白を空けて、1 ≤ j ≤ n という範囲で動く変数となる。 昇順バブルソート function BubbleSort(a) { var n = a.length; for (var i = 0; i < n -1; i++) { for (var j = i + 1; j < n; j++) { if (a[i] > a[j]) { [a[i], a[j]] = [a[j], a[i]]; } } } return a; } 3.4 基本選択法（選択ソート） 基本選択法（選択ソート）は、 1. 対象とするデータの中から最小値（降順なら最大値）を取り出す 2. 先頭のデータと交換 という操作を繰り返すことにより、全体を整列させる方法である。 ","3.4 基本選択法（選択ソート） 15 昇順選択ソート（再帰版） function SelectSort(a, start = 0) { var n = a.length; var minIndex = start; for (var j = start + 1; j < n; j++) { if (a[j] < a[minIndex]) { minIndex = j; } } [a[start], a[minIndex]] = [a[minIndex], a[start]]; start++; return (start == n) ? a : SelectSort(a, start); } 再帰を使わずに表す場合は、添字 i を動かすことで先頭を少しずつずらしていく。 昇順選択ソート（二重ループ版） function SelectSort(a) { var n = a.length; for (var i = 0; i < n; i++) { var minIndex = i; ","3.5 基本挿入法（挿入ソート） 16 for (var j = i + 1; j < n; j++) { if (a[j] < a[minIndex]) { minIndex = j; } } [a[i], a[minIndex]] = [a[minIndex], a[i]]; } return a; } 3.5 基本挿入法（挿入ソート） 基本挿入法（挿入ソート）は、 1. 対象とするデータ列を「整列済み」と「未整列」のものに分ける 2. 未整列データを、一つずつ整列済みの列の適切な位置に挿入する という操作を繰り返すことにより、全体を整列させる方法である。 昇順挿入ソート（再帰版） function InsertSort(a, unaligned = 1) { var n = a.length; for (var j = 0; j < unaligned; j++) { ","3.5 基本挿入法（挿入ソート） 17 if (a[j] > a[unaligned]) { [a[j], a[unaligned]] = [a[unaligned], a[j]]; } } unaligned++; return (unaligned < n) ? InsertSort(a, unaligned) : a; } 昇順挿入ソート（二重ループ版） function InsertSort(a) { var n = a.length; for (var i = 0; i < n; i++) { var unaligned = i + 1; for (var j = 0; j < unaligned; j++) { if (a[j] > a[unaligned]) { [a[j], a[unaligned]] = [a[unaligned], a[j]]; } } } return a; } ","3.6 シェルソート 18 3.6 シェルソート シェルソートは、 1. ある一定間隔おきに取り出した要素で部分列を作る 2. それぞれの部分列を整列して、合体させる 3. 今度は間隔を狭めてまた部分列を作る 4. それぞれの部分列を整列して、合体させる という操作を、取り出す間隔が 1 になるまで繰り返すことにより、全体を整列させる方法 である。 昇順シェルソート function ShellSort(a) { // 配列の要素数 var n = a.length; // 何個おきに分割するかの間隔 var h = 0; // 間隔は 3 の倍数 +1 とする // 初期値は大きすぎると遅くなるため、n/9 を上限とする while (h <= n / 9){ h = 3 * h + 1; } // 間隔が 1 以上である限り続ける while (h >= 1) { for (var i = h; i < n; i++) ","3.6 シェルソート 19 { var j = i; // i より左側に着目し、 // h 個離れた要素と比較・交換という作業を 1 つずつ左にずらし て行う。 , → // // 今見ている要素 a[j] と、 // そこから h 個前にある要素 a[j - h] の大小を比較し、 // 前にある a[j - h] の方が大きければ、小さい順にするために 入れ替える。 , → // j - h >= 0、つまり h 個前の要素 a[j - h] が配列内に存在 する限り続ける , → while (j >= h && a[j -h] > a[j]) { [a[j], a[j -h]] = [a[j -h], a[j]]; j--; } } // 間隔 h=3 の倍数 +1 という関係は保ったまま、 // さらに細かく分割 h = Math.floor(h / 3); } return a; } ","3.7 マージソート 20 3.7 マージソート マージソートは、 1. 配列の 2 分割を繰り返して、それぞれの配列の要素数が 1 となるまで細分化する 2. お互いの値を比較して並べ替えながら併合していき、一つの配列に戻す という操作により、全体を整列させる方法である。 昇順マージソート // 配列 A の left から right までの範囲をマージソート function MergeSort(A, B = [], left = 0, right = A.length) { // 配列の大きさが 1 以下であればソート済み if (right -left <= 1){ return A; } // 配列を二等分するため、中央のインデックスを求める var mid = (left + right) / 2; // 要素数が奇数の場合、mid は小数になるので切り捨て mid = Math.floor(mid); // 配列の前半と後半をそれぞれソートする MergeSort(A, B, left, mid); MergeSort(A, B, mid, right); // ソートした配列をマージする return Merge(A, B, left, mid, right); } ","3.7 マージソート 21 配列のマージ // 配列をソートしながらマージ function Merge(A, B, left, mid, right) { // 配列 A は mid を境に 2 つに分割されているものとみなす // l は前半の配列のインデックス // m は後半の配列のインデックス var l = left; var m = mid; // 配列 B は作業時のデータ一時保管用 // i は配列 B のインデックス var i = 0; // 前半は mid までなので、l は mid を超えない // 後半は right までなので、m は right を超えない while (l < mid && m < right) { // 前半と後半の要素を先頭から順に比べて、 // 小さい方の要素を B に入れる // 同じ大きさの値であれば、安定ソートにするために、 // 前半にあった要素を B に入れる if (A[l] <= A[m]) { B[i++] = A[l++]; } else { B[i++] = A[m++]; } } // 前半の要素 l が先に境界に達した（全て B に入れ終わった）なら、 ","3.8 クイックソート 22 // まだ B に入れていない後半の要素を B に詰め込む // 逆に、後半の要素 m が先に境界に達した（全て B に入れ終わった）なら、 // まだ B に入れていない前半の要素を B に詰め込む if (l == mid){ while (m < right){ B[i++] = A[m++]; } } else { while (l < mid){ B[i++] = A[l++]; } } // 配列 B の中身を、配列 A の left 以降にコピーする for (var k = 0; k < i; k++) { A[left + k] = B[k]; } return A; } 3.8 クイックソート クイックソートは、 1. 中間的な基準値を決めて、「それより小さい値」と「それより大きい値」に分ける 2. それぞれのグループ内でまた基準値を決めて、分類 という操作を繰り返すことにより、全体を整列させる方法である。 ","3.8 クイックソート 23 昇順クイックソート // 配列 A の left から right までの範囲をクイックソート function QuickSort(A, left = 0, right = A.length) { // 左端の要素を指すインデックス var l = left; // 右端の要素を指すインデックス var r = right; // 中央の要素を指すインデックス var m = Math.floor((l + r) / 2); // ピボットを指すインデックス var p; // 左端要素、中央要素、右端要素の 3 つを昇順にして、中央要素を更新する m = settingPivot(A, l, m, r); // 中央要素と右端から 2 番目の要素を入れ替える [A[m], A[r -1]] = [A[r -1], A[m]]; // 今は右端から 2 番目にある、元々 A[m] だった要素をピボットとする p = r -1; // 左端 < 右端 -1< 右端 という関係が成り立っており、 // 右端 -1 がピボットだから、 // 左端の要素はピボット未満、右端の要素はピボット以上 // であることが保証されているので、 // これらの要素とピボットを走査範囲から除外する。 l += 1; r -= 2; ","3.8 クイックソート 24 // 配列 A の l から r までの範囲を、pivot 以上の範囲と pivot 未満の範囲 に分割する , → partition(A, l, r, A[p]); // r がまだ整列範囲の左端 left に達していないなら、 // 走査範囲をまだ通っていない箇所に狭めてクイックソートを続ける if (left < r){ QuickSort(A, left, r); } // l がまだ整列範囲の右端 right に達していないなら、 // 走査範囲をまだ通っていない箇所に狭めてクイックソートを続ける if (l < right){ QuickSort(A, l, right); } // 終了 return A; } 適切なピボットを求める // 配列 A 内の指定した 3 値を昇順にソートして、中央値を返す function settingPivot(A, idx1, idx2, idx3) { // A[1] より A[2] の方が小さければひっくり返す if (A[idx2] < A[idx1]) { [A[idx2], A[idx1]] = [A[idx1], A[idx2]]; } // A[2] より A[3] の方が小さければひっくり返す ","3.8 クイックソート 25 if (A[idx3] < A[idx2]) { [A[idx3], A[idx2]] = [A[idx2], A[idx3]]; } // A[1] は今、1 か 2 にある。 // A[3] は今、2 か 3 にある。 // // A[3] が 3 のままなら、前で 1 と 2 が入れ替わっている可能性があるが、 // どちらにせよ 2 の位置に来た値より A[3] が大きいことは証明済みなの で、既に昇順になっている。 , → // // A[3] が 2 の位置に来ている場合、A[3] と A[2] は小さい順に並んでい る。 , → // この時、A[1] は 1 か 3 にあるが、3 にある場合は、A[2] < A[3] < A[1] であり既に昇順になっている。 , → // // A[1] が 1 のままなら、後ろで 2 と 3 が入れ替わっている可能性がある が、 , → // 2 の位置に来た値と A[1]（1 の位置にある値）の大小はわからない。… ☆ , → // // A[1] が 2 の位置に来ている場合、A[1] と A[2] は小さい順に並んでお り、 , → // 2 にある値（A[1]）と 3 にある値は比較済みなので、既に昇順になって いる。 , → // // 以上より、☆に該当する場合はまだ昇順になっていないため、 // 2 の位置にある値と 1 の位置にある値を比較する必要がある。 if (A[idx2] < A[idx1]) { [A[idx2], A[idx1]] = [A[idx1], A[idx2]]; } ","3.8 クイックソート 26 // 中央値を返す return idx2; } ピボットによる分割 // 配列 A の l から r までの範囲を、pivot 以上の範囲と pivot 未満の範囲に分 割する , → function partition(A, l, r, pivot) { // l は今、走査範囲の左端を指している // A[l] が pivot 未満の要素である限り、右に進んでいく // つまり、pivot 以上の要素にたどり着くまで、右に進んでいく while (A[l] < pivot){ l++; } // r は今、走査範囲の右端を指している // A[r] が pivot より大きい要素である限り、左に進んでいく // つまり、pivot 以下の要素にたどり着くまで、左に進んでいく while (A[r] > pivot){ r--; } // 現在の A[l] は pivot 以上の要素 // 現在の A[r] は pivot 以下の要素 // A[l] が A[r] より左にあるなら、昇順にするために交換する if (l <= r){ [A[l], A[r]] = [A[r], A[l]]; // 次の走査に備えて、今入れ替えた場所までを走査範囲から除外 l++; ","3.9 ヒープソート 27 r--; } } 3.9 ヒープソート ヒープソートは、 1. 未整列のデータ列で二分探索木を作る 2. 根（最大値）を取り出して整列済みの列へと移す という操作を繰り返すことにより、全体を整列させる方法である。 ヒープソートにはデータ構造編で掲載しているヒープクラスを使用するため、ヒープソー トに限りサンプルコードは Ruby で記述している。 降順ヒープソート def HeapSort(a) n = a.length heap = Heap.new(n) i = 0 while i < n heap.push(a[i]) i += 1 end i = 0 while i < n a[i]= heap.pop i += 1 ","28 end return a end 第 II 部 データ構造 データ構造のサンプルコードは Ruby で記述している。 4 配列 4.1 概要 配列 （ array ）は、同じ大きさの要素が連続して並んだデータ構造である。 データはメモリの連続した領域に、順番通りに格納されている。 左から順に 0 から番号を振っていき、この番号（ 添字 、 インデックス ）を使って要素を 指定する。 MyArray クラスの雛形 class MyArray # array, number のアクセサを作成 attr_accessor :array, :number # 指定された大きさの配列を作成する def initialize(maxSize) # データを格納する領域（空の配列）を用意 ","4.2 データの取得 29 @array = Array.new(maxSize) # 格納されているデータ数 @number = 0 end # ここにメソッドを追加していく end 4.2 データの取得 データは連続した領域に格納されているため、メモリアドレス（メモリ上の位置）が添字 を使って計算でき、各データに直接アクセス（ ランダムアクセス ）できる。 そのため、データの取得時の計算量は O(1) で済む。 指定した場所のデータを取得するメソッド def get(position) return self.array[position] end 4.3 データの挿入 配列の任意の場所にデータを挿入するには、挿入箇所以降のデータを一つずつ後ろにずら して挿入箇所を空ける必要がある。 そのため、最後尾にデータを挿入する場合は挿入分の処理 1 回で済むが、 先頭にデータを挿入する場合は、全てのデータ（n 個）をずらしてから挿入処理を行う必 ","4.3 データの挿入 30 要があるから、最悪計算量は O(n) といえる。 指定した場所にデータを挿入するメソッド def insert(position, data) # 指定した場所が領域外なら挿入は行わず終了 if position < 0 || position > self.number puts 無理でした return end # 配列がいっぱいであれば挿入は行わない # 格納している要素の数が配列の長さ（指定した maxSize）に達していた ら、次の左にずらす操作ができない , → if self.array.length == self.number puts 無理でした return end # position より後ろにあるデータを順に 1 個ずつ後ろにずらして、挿入位 置を空にする , → shiftEnd = self.number while position <= shiftEnd self.array[shiftEnd + 1]= self.array[shiftEnd] shiftEnd -= 1 end # データが 1 つ増やすので、配列のデータ数を更新 self.number += 1 # データを空けた場所に挿入する self.array[position]= data end ","4.4 データの削除 31 4.4 データの削除 配列の任意の場所のデータを削除する場合、削除した後にその空いた領域を前に詰める必 要がある。 そのため、最後尾のデータを削除する場合は削除分の処理 1 回で済むが、 先頭のデータを削除する場合は、後ろに続く n − 1 個のデータを前にズラす必要があるた め、最悪計算量は O(n) となる。 指定した場所のデータを削除するメソッド def remove(position) # 指定した場所が領域外なら削除は行わず終了 if position < 0 || position > self.number puts 無理でした return end # position より後ろにあるデータをそれぞれ 1 つ前にズラす shiftStart = position + 1 while shiftStart < self.number self.array[shiftStart]= self.array[shiftStart + 1] shiftStart += 1 end #1 個削除したため、データ数を更新 self.number -= 1 # データが 1 つ減ったことで、末尾のスペースは空く self.array[self.number]= nil end ","32 5 連結リスト 値に加えて、次のデータへの参照（ リンク 、 ポインタ ）をもつデータ構造を 連結リスト （ Linked List ）という。 データはメモリ上の連続した領域に格納される必要はなく、一般には離れた場所にバラバ ラに格納される。 5.1 単方向連結リスト 次のデータへの参照のみをもつ連結リストを 単方向連結リスト （ Singly Linked List ） という。 リストの各要素を表すクラス class SinglyLinkedListElement # 各種データのアクセサ attr_accessor :data, :next # 指定されたデータを保持する要素を生成 def initialize(data) @data = data @next = nil end end SinglyLinkedList クラスの雛形 class SinglyLinkedList # アクセサ ","5.1 単方向連結リスト 33 attr_accessor :firstElement # 空の連結リストを生成する def initialize() # 先頭を指し示すための要素を作成する @firstElement = SinglyLinkedListElement.new(nil) end # ここにメソッドを追加していく end 5.1.1 データの取得 データはバラバラに格納されているため、各データにはポインタを先頭から辿っていくこ とでしかアクセスできない。 このアクセス方式を 順次アクセス （ シーケンシャルアクセス ）という。 まずは、指定された場所の要素（データの格納箱）までポインタを辿って移動する必要が ある。 先頭から探していく線形探索を行うことになるため、計算量は O(n) となる。 指定した場所の要素を取得するメソッド # 指定した場所の要素を取得する def getElement(position) currentElement = self.firstElement currentPosition = 0 # 指定された場所まで、先頭から順番に移動する while currentPosition < position ","5.1 単方向連結リスト 34 # リストの最後まで到達したら、探索失敗 if currentElement == nil puts 見つかりません return end # 次の要素へ移動 currentElement = currentElement.next currentPosition += 1 end return currentElement end データの格納箱が見つかったら、その中にあるデータを取得することができる。 指定した場所のデータを取得するメソッド # 指定した場所の要素がもつデータを取得する def get(position) # 指定された場所に Element オブジェクトがあると仮定して、それを取得 targetElement = self.getElement(position) # 指定された場所に Element オブジェクトがなければ、エラーメッセージ を表示 , → if !targetElement puts 見つかりません return end return targetElement.data end ","5.1 単方向連結リスト 35 5.1.2 データの挿入 データの挿入は、追加する前後のポインタを差し替えるだけなので、簡単に行える。 どこにデータを挿入するとしても、繰り返し処理は発生しないので、計算量は O(1) と なる。 指定した場所にデータを挿入するメソッド # 指定した場所の要素にデータを挿入する def insert(position, data) # 指定した場所を指す要素（指定した場所の前の要素）を取得 previousElement = self.getElement(position -1) # 指定された場所が不正なら、エラーメッセージを表示 # ・負の数は指定できない # ・前の要素が null なら、挿入した要素を指し示してはくれないため、挿 入不可能 , → if position < 0 || previousElement == nil puts 無理です return end # 新しく挿入する要素を作成 element = SinglyLinkedListElement.new(data) # 新しい要素の指す先を変更 # previousElement は元々次にあった要素を指しているが、 # previousElement とその次の要素との間に element が割り込んだので、 # element の指す先は previousElement の次の要素だった要素となる element.next = previousElement.next #1 つ前の要素の指す先を新しい要素とする previousElement.next = element end ","5.1 単方向連結リスト 36 5.1.3 データの削除 データの挿入も挿入と同様に、ポインタを差し替えるだけで簡単に行える。 どこにデータを挿入するとしても、繰り返し処理は発生しないので、計算量は O(1) と なる。 指定した場所のデータを削除するメソッド # 指定した場所の要素がもつデータを削除する def remove(position) # 削除したい要素を取得 targetElement = self.getElement(position) # 指定された場所が不正なら、エラーメッセージを表示 # ・負の数は指定できない # ・前の要素が null なら、挿入した要素を指し示してはくれないため、挿 入不可能 , → if position < 0 || targetElement == nil puts 無理です return end # 削除する要素の 1 つ前の要素を取得 previousElement = self.getElement(position -1) #1 つ前の要素の指す先を、削除する要素の次の要素に変更 previousElement.next = targetElement.next # 削除される要素は、何も指すことはない targetElement.next = nil end ","5.2 双方向連結リスト 37 5.2 双方向連結リスト 次のデータへの参照と前のデータへの参照を両方もつ連結リストを 双方向連結リスト （ Doubly Linked List ）という。 リストの各要素を表すクラス class DoublyLinkedListElement # 各種データのアクセサ attr_accessor :data, :next, :previous # 指定されたデータを保持する要素を生成 def initialize(data) @data = data @next = nil @previous = nil end end DoublyLinkedList クラスの雛形 class DoublyLinkedList # アクセサ attr_accessor :firstElement, :lastElement # 空の連結リストを生成する def initialize() # 先頭を指し示すための要素を作成する @firstElement = DoublyLinkedListElement.new(nil) ","5.2 双方向連結リスト 38 # 最後尾を指し示すための要素を作成する @lastElement = DoublyLinkedListElement.new(nil) # まだ空なので、最初の要素の次の要素は最後の要素 self.firstElement.next = self.lastElement # まだ空なので、最後の要素の前の要素は最初の要素 self.lastElement.previous = self.firstElement end # ここにメソッドを追加していく end 差し替えるポインタの数が増えるだけで、データ操作は単方向の時と同様に行われる。 ポインタの数が増えたことで、前にも後ろにも辿ることができるようになったが、データ 格納のための領域が多くなるという欠点もある。 5.2.1 データの取得 指定した場所の要素を取得するメソッド # 指定した場所の要素を取得する def getElement(position) currentElement = self.firstElement currentPosition = 0 # 指定された場所まで、先頭から順番に移動する while currentPosition < position # リストの最後まで到達したら、探索失敗 if currentElement == nil puts 見つかりません return ","5.2 双方向連結リスト 39 end # 次の要素へ移動 currentElement = currentElement.next currentPosition += 1 end return currentElement end 指定した場所のデータを取得するメソッド # 指定した場所の要素がもつデータを取得する def get(position) # 指定された場所に Element オブジェクトがあると仮定して、それを取得 targetElement = self.getElement(position) # 指定された場所に Element オブジェクトがなければ、エラーメッセージ を表示 , → if !targetElement puts 見つかりません return end return targetElement.data end ","5.2 双方向連結リスト 40 5.2.2 データの挿入 指定した場所にデータを挿入するメソッド # 指定した場所の要素にデータを挿入する def insert(position, data) # 指定した場所を指す要素（指定した場所の前の要素）を取得 previousElement = self.getElement(position -1) # 指定された場所が不正なら、エラーメッセージを表示 # ・負の数は指定できない # ・前の要素が null なら、挿入した要素を指し示してはくれないため、挿 入不可能 , → if position < 0 || previousElement == nil puts 無理です return end # 新しく挿入する要素を作成 element = DoublyLinkedListElement.new(data) # 新しい要素の指す先を変更 # previousElement は元々次にあった要素を指しているが、 # previousElement とその次の要素との間に element が割り込んだので、 # element の指す先は previousElement の次の要素だった要素となる element.next = previousElement.next # previousElement の次の要素だった要素は、その前に割り込んできた element を指すようになる , → previousElement.next.previous = element #1 つ前の要素の指す先を新しい要素とする previousElement.next = element # element は previousElement の直後に割り込んだので、 # element の 1 つ前の要素は previousElement となる element.previous = previousElement ","5.2 双方向連結リスト 41 end 5.2.3 データの削除 指定した場所のデータを削除するメソッド # 指定した場所の要素がもつデータを削除する def remove(position) # 削除したい要素を取得 targetElement = self.getElement(position) # 指定された場所が不正なら、エラーメッセージを表示 # ・負の数は指定できない # ・前の要素が null なら、挿入した要素を指し示してはくれないため、挿 入不可能 , → if position < 0 || targetElement == nil puts 無理です return end # 削除する要素の 1 つ前の要素を取得 previousElement = self.getElement(position -1) #1 つ前の要素の指す先を、削除する要素の次の要素に変更 previousElement.next = targetElement.next # 削除する要素の次の要素は、削除する要素の前の要素を指すようになる targetElement.next.previous = targetElement.previous # 削除される要素は、何も指すことはない targetElement.next = nil targetElement.previous = nil end ","5.3 循環（環状）リスト 42 5.3 循環（環状）リスト 単方向連結リストでは、リストの最後尾の要素はポインタを持っていなかったが、最後尾の 要素が先頭の要素を指すようにすることで、輪のようにみなした連結リストを 循環リスト （ 環状リスト ）という。 輪っかなので先頭や最後尾という概念がなくなり、常に一定個の最新のデータを保持して おきたい時などに使われる。 6 スタック データの挿入と取得をリストの特定の一端で行うようなデータ構造を スタック という。 積み上げた本は、最後に積んだ本から下ろしていくしかない。 これと同様に、スタックでは必ず最後に入れたデータを最初に出すことになる。 このような方式を 後入れ先出し （ LIFO ： Last In First Out ）という。 また、本の積み上げのイメージから、 • スタックにデータを追加する操作を 積む （ プッシュ ） • スタックからデータを取り出す操作を おろす （ ポップ ） という。 データを積み上げるというイメージから、 • スタックの最初にデータを入れた場所を ボトム • スタックの最後にデータを入れた場所を トップ という。 現在トップがどこにあるのかを指し示す場所を スタックポインタ という。 ","43 Stack クラス class Stack # アクセサ attr_accessor :stack, :maxSize, :stackPointer # 指定された大きさのスタックを生成 def initialize(maxSize) # データを格納する領域（空の配列）を用意 @stack = Array.new(maxSize) # 格納できるデータ数 @maxSize = maxSize # スタックのトップを指すポインタ（データ数を表す） # トップの次の、データが何も入っていない領域を指している @stackPointer = 0 end # スタックがいっぱいかどうか調べる def isFull? return self.stackPointer == self.maxSize end # スタックが空かどうか調べる def isEmpty? return self.stackPointer == 0 end # スタックにデータを積む（データの追加） def push(data) # スタックがいっぱいならこれ以上積めない if self.isFull? return 溢れるので無理です ","44 end # スタックにデータを積む self.stack[self.stackPointer]= data # stsckPointer の位置にデータを挿入したので、 # その次の何も入っていない領域を指すように変更する self.stackPointer += 1 end # スタックからデータをおろす（データの取り出し） def pop # スタックが空ならおろすデータがない if self.isEmpty? return おろせるデータがありません end # stackPointer の位置には何も入っていないので、 # その前のトップを指すように変更する self.stackPointer -= 1 # トップにあるデータを取得 getData = self.stack[self.stackPointer] # データを取り出した箇所は空になる self.stack[self.stackPointer]= nil # 取得したデータを渡す return getData end end データの追加もデータの取り出しも、繰り返し処理は発生しないため、計算量は O(1) で 済む。 ","45 7 キュー（待ち行列） リストの一方の端ではデータの挿入のみを、もう一方の端ではデータの取り出しと削除の みを行うようなデータ構造を キュー （ 待ち行列 ）という。 順番待ちの行列では、最初に並んだ人から順に中に入ることができる。 これと同様に、キューでは必ず最初に入れたデータを最初に出すことになる。 このような方式を 先入れ先出し （ FIFO ： First In First Out ）という。 • キューにデータを追加する操作を エンキュー • キューからデータを取り出す操作を デキュー という。 順番待ちの行列のイメージから、 • キューの最初にデータを入れた場所を 先頭 （ フロント ） • キューの最後にデータを入れた場所を 末尾 （ リア ） という。 有限の領域である配列でキューを実現しようとすると、データを取り出す度に配列の先頭 に領域が空き、その隙間分全体を前にずらさないと、後方にデータを追加することができ なくなってしまう。 しかし、全ての要素を前にズラすという操作をそのまま実装すると計算量が膨大 になってしまうため、配列の片端から溢れたデータをもう一方の端に回り込ませ る ラップアラウンド という方法で実装されることが多い。 輪とみなすことで、前と後ろという区別がなくなるため、「先頭側の領域を詰める」「後方 側の領域を空ける」という操作が不要になる。 ","46 Queue クラス class Queue # アクセサ attr_accessor :queue, :rear, :front, :maxSize # 指定された大きさのキューを生成 def initialize(maxSize) # データを格納する領域（空の配列）を用意 @queue = Array.new(maxSize) # 格納できるデータ数 @maxSize = maxSize # フロント（データ列の先端） @front = 0 # リア（データ列の終端） @rear = 0 end # キューが満杯かどうか調べる def isFull? # リアの次の要素がフロントなら満杯 return self.rear + 1 == self.front end # キューが空かどうか調べる def isEmpty? # リアとフロントが一致すれば空 return self.front == self.rear end # キューにデータを追加する def enqueue(data) ","47 # キューがいっぱいならこれ以上追加できない if self.isFull? return 溢れるので無理です end # データを追加する self.queue[self.rear]= data self.rear += 1 # リアが確保した領域の端まで達したら、領域の先頭に回り込ませる if self.rear == self.maxSize self.rear = 0 end end # キューからデータを取り出す def dequeue # キューが空なら取り出すデータがない if self.isEmpty? return 取り出せるデータがありません end # フロントにあるデータを取得 getData = self.queue[self.front] # データを取り出しした箇所を空にする self.queue[self.front]= nil # sele.front の位置は空になったので、 # その次の要素をフロント（データの先端）とする self.front += 1 # フロントが確保した領域の端まで達したら、領域の先頭に回り込ませ る , → if self.front == self.maxSize self.front = 0 end ","48 # 取得したデータを渡す return getData end end データの追加もデータの取り出しも、繰り返し処理は発生しないため、計算量は O(1) で 済む。 8 ハッシュ 9 木 木 とは、データが子供データを複数持つことができるデータ構造である。 子供データから見て、元のデータは 親 と呼ばれる。 親 子 子 1 つ 1 つのデータのことを 頂点 or 節 or ノード と呼ぶ。 子供データへの参照を 枝 （ エッジ ）と呼ぶ。 節 節 節 枝 枝 ","49 各ノードは多くても 1 つの親をもつが、 親がないノードが 1 つだけあり、これを 根 （ ルート ）という。 子供を持たない節もあり、これを 葉 （ リーフ ）という。 根 節 節 葉 葉 頂点から根にたどり着くまでに通らなければならない枝の数をその頂点の 深さ という。 頂点から葉にたどり着くまでに通らなければならない枝の数をその頂点の 高さ という。 根の高さで一番高いものを、その木全体の 高さ と定義する。 自分と同じ親をもつノードを 兄弟 という。 図示する際は、 兄 を左に書くことが多い。 親 弟 兄 親を辿っていくことで辿り着けるノードを 先祖 （ 祖先 ）という。 ","9.1 2 分木 50 子を辿っていくことで辿り着けるノードを 子孫 という。 9.1 2 分木 節から伸びる枝がすべて 2 本以下 である木を二分木という。 二分木の各ノードを表すクラス # 二分木の各ノードを表すクラス class TreeNode # アクセサ attr_accessor :data, :left, :right # 指定したデータをもつ木のノードを生成 def initialize(data) @data = data # まだ子は持たない @left = nil @right = nil end end 二分木を表すクラス # 二分木を表すクラス class BinaryTree # アクセサ attr_accessor :root ","9.2 完全 2 分木 51 # 空の二分木を生成 def initialize() @root = nil end # 子を置換するメソッド def replace(parent, oldNode, newNode) # parent が nil の時は、親が存在しないノードであるルートを置換 if parent.nil? self.root = newNode # 置換したいノードに一致する子を見つけて置換 elsif parent.left == oldNode parent.left = newNode elsif parent.right == oldNode parent.right = newNode else return 子が見つかりません end end end 9.2 完全 2 分木 葉以外の節が全て 2 つの子をもち、 根から葉までの深さ が一様に等しい二分木 を 完全二分木 （ Full Binary Tree ）という。 ","9.3 2 分探索木 52 根 節 葉 葉 節 葉 葉 根 節 節 葉 葉 節 葉 葉 節 節 葉 葉 節 葉 葉 上から順に左詰めで要素を埋めていって、その深さの要素が埋め尽くされるまで次の深さ に行かないような二分木を 完全二分木 （ Complete Binary Tree ）という。 具体的には、次の条件を満たすものである。 • 最下層より上は Full Binary Tree • 最下層は 左詰め 1 2 3 3 2 3 1 2 3 4 4 3 2 3 3 9.3 2 分探索木 二分木のうち、全てのノードの値が 左の子孫の値 ≤ 自分の値 ≤ 右の子孫の値 となっているものを二分探索木という。 ","9.3 2 分探索木 53 15 9 3 8 12 23 17 28 二分探索木を表すクラスの雛形 # 二分探索木を表すクラス（二分木を表すクラスを継承） class BinarySearchTree < BinaryTree # コンストラクタは BinaryTree クラスのものをそのまま使うので書かない # ここにメソッドを追加していく end 二分探索木は全体だけでなく、各部分も小さな木（ 部分木 ）とみなせるため、 各メソッドの実装には 再帰 を使うことが多い。 ","9.3 2 分探索木 54 9.3.1 データの探索 指定した値を探索するメソッド（存在有無の判定） # node 以下に指定した値をもつノードが存在するかを判定する def contain?(targetValue, node = self.root) # 木が空であれば、指定したデータは存在しない if node.nil? return false end # node が指定したデータだった場合 if node.data == targetValue return true end # node が指定したデータではなかった場合、 # 二分探索と同じように絞り込む if targetValue < node.data self.contain?(targetValue, node.left) else self.contain?(targetValue, node.right) end end contain?メソッドを呼び出す度に、葉へ向かって 1 つ下に下りることになるため、 一番深い葉へ進んだ場合、計算量は最大となり、 木の高さ と同じになる。 木の形が 左右対称 に近ければ近いほど（多くの葉が 近 い階層にあればあるほど） 木の高 さは小さくなり、一番深い葉まで下りることになったとしても、計算量は少なく済む。 contain?メソッドでは二分探索と同様の絞り込みによって探索を行うため、平均計算量は ","9.3 2 分探索木 55 二分探索と同様に log 2 n となる。（n は木の高さ） contain?メソッドを応用して、見つけたい値の存在有無だけでなく、その値をもつノード までの経路（ パス ）を知らせてくれるメソッドを定義しておく。 見つけたい値にたどり着くまでの間、目印のパンくずを落としながら進んでいくイメージ で、 一階層ごとに • 左へ進んだ場合は −1 • 右へ進んだ場合は 1 を配列に追加していく。 指定した値を探索するメソッド（パスの取得） # 指定したノードを根として、指定した値をもつノードへのパスを取得する def path(targetValue, node = self.root, breadcrumbs = []) # 木が空であれば、指定したデータは存在しない if node.nil? return false end # node が指定したデータだった場合 if node.data == targetValue return breadcrumbs end # node が指定したデータではなかった場合、 # 二分探索と同じように絞り込む if targetValue < node.data breadcrumbs.push(-1) self.path(targetValue, node.left, breadcrumbs) else breadcrumbs.push(1) ","9.3 2 分探索木 56 self.path(targetValue, node.right, breadcrumbs) end end 最小値、最大値を探索するメソッドも、ノード削除に必要となるため、定義しておく。 最小値を探索するメソッド # 指定したノードを根とする木の中から最小の値をもつノードを取得 def minNode(node = self.root) # 指定されたノードが null であれば、子ノードは存在しないので探索しよ うがない , → if node.nil? return 木は空です end # 左の子は親より小さい # 指定したノードに左の子が存在しなければ、指定したノードが最小値 if node.left.nil? return node else minNode(node.left) end end 最大値を探索するメソッド # 指定したノードを根とする木の中から最大の値をもつノードを取得 def maxNode(node = self.root) ","9.3 2 分探索木 57 # 指定されたノードが null であれば、子ノードは存在しないので探索しよ うがない , → if node.nil? return 木は空です end # 右の子は親より大きい # 指定したノードに右の子が存在しなければ、指定したノードが最大値 if node.right.nil? return node else maxNode(node.right) end end 9.3.2 データの挿入 指定した値を適切な場所に挿入するメソッド # 指定した値を適切な場所に挿入する def insert(value) # 指定した値を指定したノードを根とする部分木に挿入するメソッドを定義 def insert_inPart(value, node) # 根と比べて小さければ、左下に降りる if value < node.data # 降り立った左の領域が空なら、そこに挿入 if node.left.nil? node.left = TreeNode.new(value) return # さらに下にも部分木が続くなら、比較を続ける ","9.3 2 分探索木 58 else insert_inPart(value, node.left) end # 根と比べて大きければ、右下に降りる else if node.right.nil? node.right = TreeNode.new(value) return else insert_inPart(value, node.right) end end end # 既に存在する値は挿入できない if self.contain?(value) return 既にある値は挿入できません end # 木が空であれば、データをルートノードに設置 if self.root.nil? self.root = TreeNode.new(value) return else insert_inPart(value, self.root) end end ","9.3 2 分探索木 59 9.3.3 データの削除 指定した値を削除するメソッド # 指定した値を削除する def delete(value) # 削除対象のノードへの経路を取得 path = self.path(value) # 削除対象のノードがなければ終了 if !path return 見つかりません end # 削除対象のノードとその親を取得 targetNodeParent = nil targetNode = self.root for i in path targetNodeParent = (targetNode == self.root) ? nil : targetNode , → if i < 0 targetNode = targetNode.left else targetNode = targetNode.right end end # ^^e2^^91^^a0 削除対象のノードが子を持たない場合 if targetNode.left.nil? && targetNode.right.nil? # 削除するだけ targetNode = nil # ^^e2^^91^^a1 削除対象のノードが右の子のみもつ場合 elsif targetNode.left.nil? # 削除対象ノードの子を、削除対象ノードがあった位置にズラす ","9.3 2 分探索木 60 targetNodeChild = targetNode.right self.replace(targetNodeParent, targetNode, targetNodeChild) , → # ^^e2^^91^^a2 削除対象のノードが左の子のみもつ場合 elsif targetNode.right.nil? # 削除対象ノードの子を、削除対象ノードがあった位置にズラす targetNodeChild = targetNode.left self.replace(targetNodeParent, targetNode, targetNodeChild) , → # ^^e2^^91^^a3 削除対象のノードが二つの子をもつ場合 # 右の子は親より大きくなければならないので、 # 右の子は下に行くにつれて大きい値をもつようになる # よって、削除してできた穴を埋めるには、 # 右の子以下で最小の値をもつノードを穴の空いた部分にずらす必要がある # （左の子以下で最大の値をもつノードを穴の空いた部分にずらす方針でも 問題はない） , → else minNode_inRight = self.minNode(targetNode.right) # 右部分木最小ノードをズラすため、一旦今の位置からは削除する self.remove(minNode_inRight.data) # 削除対象ノードが持っていた子を、右部分木内最小ノードの持ち物と する , → minNode_inRight.left = targetNode.left minNode_inRight.right = targetNode.right # 右部分木内最小ノードを、削除対象ノードのある位置に置く self.replace(targetNodeParent, targetNode, minNode_inRight) , → end end ","9.4 ヒープ 61 9.4 ヒープ 次のいずれかに該当する完全二分木（Full Binary Tree）をヒープという。 • 親の値はその子の値より必ず大きい（根が最大値） • 親の値はその子の値より必ず小さい（根が最小値） ヒープは、次のような順番で走査することで、配列と対応付けられる。 なお、わかりやすくするために配列の添字は 1 始まりとする。 1. ルートを a[1] に格納 2. 上から 2 段目のノードを左から a[2]、a[3] に格納 3. 上から 3 段目のノードを左から a[4]、a[5]、a[6]、a[7] に格納 4. ··· 以降も同様に、1 段ずつ左から詰めていく 1 2 4 8 9 5 10 3 6 7 この規則に則ると、任意の要素 a[i]（i ≥ 1） について、 • 親は　　 floor(a[i / 2]) • 左の子は a[i * 2] • 右の子は a[i * 2 + 1] という関係が成り立つ。 ","9.4 ヒープ 62 ヒープの添字の性質の証明 Proof まずは親の添字の性質について確かめる。 n 段目の要素数が c n だとすると、c n 個それぞれに子が 2 つあることから、 n +1 段目の要素数 c n+1 は、場合の数の積の法則より、 c n+1 =2c n c n+1 c n =2 すなわち、1 段あたりの要素数は、公比 2 の等比数列であるといえる。 1 段目の要素数は 1 であることから、初項は 1 であるので、 この数列の一般項（n 段目の要素数）c n は、 c n =2 n−1 よって、n(≥ 1) 段のヒープに入っている要素数の和は、 等比数列の和の公式から求められ、 S n = 2 n − 1 2 − 1 =2 n − 1 配列の添字を 1 始まりで考えると、 添字はそこまでに入っている要素数（自分を含む）となるので、 S n は、n 段目の最後の（= 最も右にある）要素の添字 last(n) を表してい ることになる。 last(n)=2 n − 1 また、n 段目の先頭の（= 最も左にある）要素は、 ","9.4 ヒープ 63 n − 1 段目の最後の要素の次の要素であるので、 その添字 first(n) は、last(n − 1) に 1 を加えたものとなる。 first(n) = (2 n−1 − 1) + 1 =2 n−1 一般化すると、n 段目の k(≥ 1) 番目の要素の添字は、 last(n − 1) に k を加えたものとなり、 k(n) = (2 n−1 − 1) + k =2 n−1 + k − 1 この値を 2 で割ってみると、 k(n) 2 =2 n−2 + k 2 − 1 2 =2 n−2 + k − 1 2 +1 − 1 =2 (n−1)−1 + k +1 2 − 1 これは、1 段上（n − 1 段目）の k +1 2 番目の項を表している。 具体的な例で考えてみる。 なお、何番目かを表す数は整数である必要があり、上の段ほど要素数は少な くなるので、小数点以下は切り捨てることにする。 • k =1 の場合、 k(n) 2 は 1 段上の floor ( 2 2 ) =1 番目の項を表す ","9.4 ヒープ 64 • k =2 の場合、 k(n) 2 は 1 段上の floor ( 3 2 ) =1 番目の項を表す • k =3 の場合、 k(n) 2 は 1 段上の floor ( 4 2 ) =2 番目の項を表す • k =4 の場合、 k(n) 2 は 1 段上の floor ( 5 2 ) =2 番目の項を表す • k =5 の場合、 k(n) 2 は 1 段上の floor ( 6 2 ) =3 番目の項を表す つまり、floor ( k(n) 2 ) は、k(n) の親要素を表している。 k(n) は任意の要素の添字であるから、 一般に、要素 a[i] の親要素は [a[i / 2]] で表される。■ 次に、子の添字の性質を確かめる。 一つの要素につき 2 つの子要素が存在するから、 n 段目の k − 1 番目の要素の右の子は、n +1 段目の 2(k − 1) 番目の要素と なる。 n 段目の k 番目の要素の左の子は、k − 1 番目の要素の右の子の隣の要素で あるから、 n +1 段目の 2(k − 1) + 1 = 2k − 1 番目の要素となる。 親の添字の証明過程で導いたように、n 段目の k 番目の要素の添字は、 k(n)=2 n−1 + k − 1 n +1 段目の 2k − 1 番目の要素の添字は、 上式において n を n +1 に、k を 2k − 1 に置き換えたものであるから、 2 (n−1)−1 + (2k − 1) − 1=2 n +2k − 2 = 2(2 n−1 + k + 1) =2 · k(n) ","9.4 ヒープ 65 よって、k(n) の左の子の添字は、2k(n) となることが確認できた。 k(n) は任意の要素の添字であるから、 一般に、要素 a[i] の左の子要素は [a[i * 2]] で表される。■ ま た 、要 素 a[i] の右の子要素は、左の子要素の右隣であるから、 a[i * 2 + 1] で表される。■ 根が最大値となるヒープを表すクラス # 根が最大値となるヒープの実装 class Heap attr_accessor :heap, :heapSize, :canHave def initialize(size) @canHave = size @heap =[0]* (size) @heapSize = 0 end protected # 葉から始めて、親要素の方が小さい場合は値を入れ替える def swapUp(index) if self.heap[index].nil? return end parentIdx = (index -1) / 2 if parentIdx < 0 || parentIdx > self.heapSize return end ","9.4 ヒープ 66 if index > 0 && self.heap[index]> self.heap[parentIdx] tmp = self.heap[index] self.heap[index]= self.heap[parentIdx] self.heap[parentIdx]= tmp self.swapUp(parentIdx) end end # 根から始めて、子の方が大きい場合は値を入れ替える def swapDown(index) if self.heap[index].nil? return end leftChildIdx = 2 * index + 1 rightChildIdx = 2 * index + 2 maxIdx = index # 左の子の方が大きければ、maxIdx を左の子のインデックスに更新 if leftChildIdx < self.heapSize && self.heap[leftChildIdx]> self.heap[maxIdx] , → maxIdx = leftChildIdx end # 右の子の方が大きければ、maxIdx を右の子のインデックスに更新 if rightChildIdx < self.heapSize && self.heap[rightChildIdx]> self.heap[maxIdx] , → maxIdx = rightChildIdx end # ここまでで maxIdx に変更があれば、maxIdx の要素が上に来るよう に入れ替える , → if index != maxIdx tmp = self.heap[index] self.heap[index]= self.heap[maxIdx] ","9.4 ヒープ 67 self.heap[maxIdx]= tmp self.swapDown(maxIdx) end end public def push(item) if self.heapSize == self.canHave puts 満杯なのでこれ以上入りません return end # 配列の一番最後に値を挿入 self.heap[self.heapSize]= item self.heapSize += 1 # 順序を整える swapUp(self.heapSize -1) end # 根（最大値）を取り出す def pop maxData = self.heap[0] # 末尾のデータと根を入れ替える self.heap[0], self.heap[self.heapSize -1]= self.heap[heapSize -1], self.heap[0] , → # 末尾に持ってきた最大値を取り出すため、要素数が減る self.heapSize -= 1 # 順序を整える self.swapDown(0) return maxData end ","9.5 AVL 木 68 end 9.5 AVL 木 "]