["SQL とデータベース設計 tomixy since 2021/11/15 目次 第 I 部 データベース概論 1 第 II 部 リレーショナルデータベース概論 1 第 III 部 SQL 1 1 データベースオブジェクトの操作 2 1.1 テーブル作成命令 ................................. 2 1.2 テーブル削除命令 ................................. 3 1.3 テーブル変更命令 ................................. 4 1.4 キー ......................................... 7 1.5 インデックス ................................... 7 1.6 制約 ......................................... 7 2 SELECT 文による抽出 8 2.1 カラムを入れ替えて表示する .......................... 10 2.2 エイリアスをつけて表示 ............................. 11 2.3 演算して表示 ................................... 12 2.4 件数・範囲を限定して表示 ............................ 16 3 WHERE 句による条件指定 17 i ","目次 ii 4 CASE 式による条件分岐 18 5 GROUP BY 句による集計 19 5.1 グループごとに表示 ................................ 19 5.2 グループごとに分けてから抽出（HAVING 句との融合） .......... 21 5.3 抽出してからグループに分ける（WHERE 句との融合） ........... 22 5.4 グループ化してから並び替える（ORDER BY 句との融合） ........ 23 6 テーブルの結合 24 6.1 同じカラム構造のテーブルの結合 ........................ 24 6.2 同じカラムをもつテーブルの結合１（一致レコードを抽出：内部結合） .. 28 6.3 同じカラムをもつテーブルの結合２（すべて抽出：外部結合） ....... 34 6.3.1 外部結合の種類 .............................. 34 6.3.2 差集合を求める .............................. 39 6.3.3 排他的和集合を求める .......................... 41 6.4 同じ名前のテーブルの結合（自己結合） .................... 58 6.4.1 順列と組合せの表現 ........................... 58 7 サブクエリ（副問い合わせ） 67 7.1 値を返すサブクエリ ................................ 67 7.2 カラムを返すサブクエリ ............................. 69 8 CASE 式による集計 72 8.1 既存のコード体系を新しい体系に変換して集計 ................ 72 8.2 異なる条件の集計を一つの SQL で行う .................... 75 8.3 条件を分岐させた UPDATE ........................... 79 8.4 テーブル同士のマッチング ............................ 81 8.5 CASE 式の中で集約関数を使う ......................... 85 9 「存在」と「全て」の扱い 88 9.1 テーブルに存在するデータの抽出 ........................ 88 9.2 テーブルに存在しないデータの抽出 ...................... 90 9.3 「すべての列が ⃝⃝」で絞り込み ....................... 92 9.4 「すべての列が ⃝⃝」で絞り込み ....................... 96 ","目次 iii 9.5 「少なくとも一つの列が ⃝⃝」で絞り込み .................. 98 10 HAVING 句と集合指向 99 10.1 NULL を含まない集合を探す .......................... 103 10.1.1 COUNT(*) と COUNT(列名) の違い .................. 103 10.2 CASE 式による特性関数と組み合わせた集計・判定 ............. 106 10.3 HAVING 句で「すべての」を扱う ....................... 113 10.4 値の重複を検出する ................................ 116 10.5 複数要件を満たすものを見つけ出す ...................... 119 11 SQL と集合演算 125 11.1 集合の相等性判定 ................................. 125 11.2 等しい部分集合の検出 .............................. 127 12 SQL と数列 132 12.1 連番の作成 ..................................... 132 12.2 全ての欠番を見つける .............................. 135 第 IV 部 リレーショナルモデルと関係代数 143 第 V 部 正規化 144 第 VI 部 トランザクション 149 ","SQL 具体例一覧 クロス表の作成 ...................................... 42 同種の情報を表す複数の列を 1 列にまとめる ..................... 45 入れ子の表を作成 .................................... 48 売れた個数を集計して帳票を作成 ........................... 55 値段は同じだが、商品名が違う商品レコードの抽出 ................. 64 ランキングの作成 .................................... 66 ランキングの作成 .................................... 70 県ごとの人口を地方ごとに再分類 ........................... 72 一次元表を二次元表に整形 ............................... 76 現在の給料によって減給か昇給かを決める ...................... 79 2 つのテーブルを id で結合してクロス表を作る ................... 81 複数のデータから主なものを抽出する ......................... 85 売上のある社員を検索 .................................. 89 出席者リストから欠席者リストを作成 ......................... 90 すべての教科が 50 点以上である生徒を検索 ..................... 92 合格点が教科により異なる場合の合格者抽出 ..................... 94 擬似配列テーブルからオール NULL の行を探す ................... 96 擬似配列テーブルから少なくとも一つの列が 9 である行を探す .......... 98 連番カラムの欠番の有無を判定する .......................... 99 最頻値を求める ...................................... 101 すべての学生がレポート提出済みの学部を検索 ................... 105 クラスの 75% 以上が 80 点以上を取ったクラスを算出 ............... 107 50% 以上を取った生徒のうち、男子が女子よりも多いクラスを算出 ........ 110 女子の平均点が男子の平均点よりも高いクラスを算出 ................ 112 全員が待機中の部隊を探す ............................... 114 資材が搬入されすぎて余っているであろう現場を特定する ............. 116 指定したすべての商品を置いている店舗を探す ................... 120 指定したすべての商品だけを置いている店舗を探す ................. 122 取扱商品がまったく同じ業者を見つける ....................... 127 3 人は並んで座れるか（一列に並ぶ座席） ...................... 137 3 人は並んで座れるか（複数列に並ぶ座席） ..................... 141 iv ","SQL 具体例一覧 v 注文データテーブルの正規化 .............................. 144 ","1 第 I 部 データベース概論 データベースを利用したいアプリケーションのために データベース機能を提供するミドルウェアのことを データベース管理システム （ DBMS ： DataBase Management System ）という。 データベースは、 • データを表で管理する 関係 型 • データを階層で管理する 階層 型 • データを網状に管理する ネットワーク 型 などに分類される。 第 II 部 リレーショナルデータベース概論 関係データベースは リレーショナルデータベース （ RDB ： Relational DataBase ）と も呼ばれ、 • 複数のデータを収容する場所である テーブル （表） • 1 件分のデータを表す レコード （行） • データを構成する各項目を表す フィールド （列） から構成される。 ","2 第 III 部 SQL 1 データベースオブジェクトの操作 データベースオブジェクト は、データベースの中に定義する、 • テーブル • ビュー • インデックス などの総称である。 データベースオブジェクトは、 スキーマ という入れ物の中に作成される。 一つのディレクトリの中に同名のファイルやフォルダを複数作成することはできない。 このことと同様に、一つのスキーマの中に同名のデータベースオブジェクトを複数作成す ることはできない。 逆に、スキーマが異なれば同じ名前のオブジェクトが存在できる。 このような特性から、スキーマは 名前空間 であるといえる。 1.1 テーブル作成命令 テーブルの作成 mysql> CREATE TABLE テーブル名 列定義リスト; サンプルテーブルの作成 CREATE TABLE ddl_test( column1 INT(11) NOT NULL, ","1.2 テーブル削除命令 3 column2 VARCHAR(30), column3 DATE ); テーブル構造の表示 DESC ddl_test; Field Type Null Key Default Extra column1 int(11) NO column2 varchar(30) YES column3 date YES 1.2 テーブル削除命令 テーブルの削除 mysql> DROP TABLE テーブル名; テーブルはそのままでデータだけをすべて削除 mysql> TRUNCATE TABLE テーブル名; ","1.3 テーブル変更命令 4 1.3 テーブル変更命令 テーブルの構造変更（基本形） mysql> ALTER TABLE テーブル名 変更命令; テーブルに列を追加 mysql> ALTER TABLE テーブル名 ADD 列定義; 列属性（特定の列のデータ型）の変更 mysql> ALTER TABLE テーブル名 MODIFY 列定義; 列名の変更 mysql> ALTER TABLE テーブル名 CHANGE COLUMN 旧列名 新列名 データ型; 列の削除 mysql> ALTER TABLE テーブル名 DROP 列名; After ：テーブルに列を追加 ALTER TABLE ddl_test ADD newColumn INTEGER; ","1.3 テーブル変更命令 5 Before ddl_test Field Type Null Key Default Extra column1 int(11) NO column2 varchar(30) YES column3 date YES After Field Type Null Key Default Extra column1 int(11) NO column2 varchar(30) YES column3 date YES newColumn int(11) YES After ：テーブルの列属性の変更 ALTER TABLE ddl_test MODIFY newColumn VARCHAR(20); Before ddl_test Field Type Null Key Default Extra column1 int(11) NO column2 varchar(30) YES column3 date YES newColumn int(11) YES ","1.3 テーブル変更命令 6 After Field Type Null Key Default Extra column1 int(11) NO column2 varchar(30) YES column3 date YES newColumn varchar(20) YES After ：テーブルの列名の変更 ALTER TABLE ddl_test CHANGE COLUMN newColumn column4 VARCHAR(20); , → Before ddl_test Field Type Null Key Default Extra column1 int(11) NO column2 varchar(30) YES column3 date YES newColumn varchar(20) YES After Field Type Null Key Default Extra column1 int(11) NO column2 varchar(30) YES column3 date YES column4 varchar(20) YES ","1.4 キー 7 After ：テーブルの列の削除 ALTER TABLE ddl_test DROP column4; Before ddl_test Field Type Null Key Default Extra column1 int(11) NO column2 varchar(30) YES column3 date YES column4 varchar(20) YES After Field Type Null Key Default Extra column1 int(11) NO column2 varchar(30) YES column3 date YES 1.4 キー 1.5 インデックス 1.6 制約 列の制約として指定できる項目は以下の通りである。 ","8 PRIMARY KEY 主キーとする UNIQUE 列内で重複する値を許可しない REFERENCES (表名) 列名 外部キーとする CHECK (条件) 条件に合う値のみ登録を許可する NOT NULL NULL 値（空の値）を許可しない DEFAULT 値 新規行追加時の初期値を指定する 表全体の制約として指定できる項目は以下の通りである。 PRIMARY KEY (列名リスト) 指定した列を主キーとする UNIQUE (列名リスト) 指定した列内で重複した値を許可しない FOREIGN KEY (列名リスト) 指定した列を外部キーとする REFERENCES 表名 (列名リスト) CHECK (条件) 条件に合う値のみ登録を許可する 2 SELECT 文による抽出 売上情報テーブルの作成 CREATE TABLE sales_info( id VARCHAR(4), sales INT, month INT ); INSERT INTO sales_info VALUES ('A103', 101, 4); INSERT INTO sales_info VALUES ('A102', 54, 5); INSERT INTO sales_info VALUES ('A104', 181, 4); INSERT INTO sales_info VALUES ('A101', 184, 4); INSERT INTO sales_info VALUES ('A103', 17, 5); INSERT INTO sales_info VALUES ('A101', 300, 5); ","9 INSERT INTO sales_info VALUES ('A102', 205, 6); INSERT INTO sales_info VALUES ('A104', 93, 5); INSERT INTO sales_info VALUES ('A103', 12, 6); INSERT INTO sales_info VALUES ('A107', 87, 6); 社員情報テーブルの作成 CREATE TABLE employees_info( id VARCHAR(4), name VARCHAR(10), age INT ); INSERT INTO employees_info VALUES ('A101', ' 富江', 40); INSERT INTO employees_info VALUES ('A102', ' 安宮', 28); INSERT INTO employees_info VALUES ('A103', ' 深沢', 20); INSERT INTO employees_info VALUES ('A104', ' 東', 23); INSERT INTO employees_info VALUES ('A105', ' 佐原', 35); 社員の出身県情報テーブルの作成 CREATE TABLE native_prefecture_info( id VARCHAR(4), prefecture VARCHAR(10) ); INSERT INTO native_prefecture_info VALUES ('A101', ' 東京都'); INSERT INTO native_prefecture_info VALUES ('A102', ' 埼玉県'); INSERT INTO native_prefecture_info VALUES ('A103', ' 神奈川県'); ","2.1 カラムを入れ替えて表示する 10 INSERT INTO native_prefecture_info VALUES ('A104', ' 北海道'); INSERT INTO native_prefecture_info VALUES ('A105', ' 静岡県'); 別営業所の社員情報テーブルの作成 CREATE TABLE another_office_employees_info( id VARCHAR(4), name VARCHAR(10), age INT ); INSERT INTO another_office_employees_info VALUES ('A106', ' 時雨', 26); INSERT INTO another_office_employees_info VALUES ('A107', ' 白沢', 24); INSERT INTO another_office_employees_info VALUES ('A108', ' 瀬崎', 23); INSERT INTO another_office_employees_info VALUES ('A109', ' 大津', 25); INSERT INTO another_office_employees_info VALUES ('A110', ' 芹川', 27); 2.1 カラムを入れ替えて表示する After ：カラムを入れ替えて表示 SELECT sales, id FROM sales_info; ","2.2 エイリアスをつけて表示 11 Before sales_info id sales month A103 101 4 A102 54 5 A104 181 4 A101 184 4 A103 17 5 A101 300 5 A102 205 6 A104 93 5 A103 12 6 A107 87 6 After sales id 101 A103 54 A102 181 A104 184 A101 17 A103 300 A101 205 A102 93 A104 12 A103 87 A107 2.2 エイリアスをつけて表示 After ：エイリアスをつけて表示 SELECT sales AS ' 売上', employee AS ' 社員番号' FROM sales_info; ","2.3 演算して表示 12 Before sales_info id sales month A103 101 4 A102 54 5 A104 181 4 A101 184 4 A103 17 5 A101 300 5 A102 205 6 A104 93 5 A103 12 6 A107 87 6 After 売上 社員番号 101 A103 54 A102 181 A104 184 A101 17 A103 300 A101 205 A102 93 A104 12 A103 87 A107 2.3 演算して表示 After ：10000 倍して表示 SELECT sales * 10000 AS ' 売上'FROM sales_info; ","2.3 演算して表示 13 Before sales_info id sales month A103 101 4 A102 54 5 A104 181 4 A101 184 4 A103 17 5 A101 300 5 A102 205 6 A104 93 5 A103 12 6 A107 87 6 After 売上 1010000 540000 1810000 1840000 170000 3000000 2050000 930000 120000 870000 After ：平均を表示 SELECT AVG(sales) FROM sales_info; ","2.3 演算して表示 14 Before sales_info id sales month A103 101 4 A102 54 5 A104 181 4 A101 184 4 A103 17 5 A101 300 5 A102 205 6 A104 93 5 A103 12 6 A107 87 6 After AVG(sales) 0.1234e3 After ：合計を表示する SELECT SUM(sales) FROM sales_info; ","2.3 演算して表示 15 Before sales_info id sales month A103 101 4 A102 54 5 A104 181 4 A101 184 4 A103 17 5 A101 300 5 A102 205 6 A104 93 5 A103 12 6 A107 87 6 After SUM(sales) 1234 After ：データの数を表示する SELECT COUNT(sales) FROM sales_info; ","2.4 件数・範囲を限定して表示 16 Before sales_info id sales month A103 101 4 A102 54 5 A104 181 4 A101 184 4 A103 17 5 A101 300 5 A102 205 6 A104 93 5 A103 12 6 A107 87 6 After COUNT(sales) 10 2.4 件数・範囲を限定して表示 After ：売上の多い順に 45 番目のレコードを表示 SELECT * FROM sales_info ORDER BY sales DESC LIMIT 2 OFFSET 3 ","17 Before sales_info id sales month A103 101 4 A102 54 5 A104 181 4 A101 184 4 A103 17 5 A101 300 5 A102 205 6 A104 93 5 A103 12 6 A107 87 6 After id sales month A104 181 4 A103 101 4 3 WHERE 句による条件指定 WHERE を使うことで、その後に指定した条件に当てはまる場所（レコード）だけ抜き出す ことができる。 After ：month が 5 か 6 のレコードに絞って表示 SELECT * FROM sales_info WHERE month IN (5, 6); ","18 Before sales_info id sales month A103 101 4 A102 54 5 A104 181 4 A101 184 4 A103 17 5 A101 300 5 A102 205 6 A104 93 5 A103 12 6 A107 87 6 After id sales month A102 54 5 A103 17 5 A101 300 5 A102 205 6 A104 93 5 A103 12 6 A107 87 6 4 CASE 式による条件分岐 CASE 式を使うと、条件によって異なる SQL 文を組み立ててもらうことができる。 After ：売上に応じて評価を追加して表示 SELECT id, sales, CASE WHEN sales >= 100 THEN ' 素晴らしい' WHEN sales >= 50 THEN ' この調子で' ELSE ' 頑張ろう' END AS ' 評価' FROM sales_info ","19 Before sales_info id sales month A103 101 4 A102 54 5 A104 181 4 A101 184 4 A103 17 5 A101 300 5 A102 205 6 A104 93 5 A103 12 6 A107 87 6 After id sales 評価 A103 101 素晴らしい A102 54 この調子で A104 181 素晴らしい A101 184 素晴らしい A103 17 頑張ろう A101 300 素晴らしい A102 205 素晴らしい A104 93 この調子で A103 12 頑張ろう A107 87 この調子で 5 GROUP BY 句による集計 5.1 グループごとに表示 例えば、GROUP BY a と記述すると、グループ a ごとに SELECT 文が実行され、グルー プに属するレコードが複数ある場合は、その中から適当に選ばれて表示される。 After ：各社員に関するレコードの件数を表示 SELECT id, COUNT(*) AS ' 件数' FROM sales_info GROUP BY id; ","5.1 グループごとに表示 20 Before sales_info id sales month A103 101 4 A102 54 5 A104 181 4 A101 184 4 A103 17 5 A101 300 5 A102 205 6 A104 93 5 A103 12 6 A107 87 6 After id 件数 A101 2 A102 2 A103 3 A104 2 A107 1 After ：各社員の売上の合計と月平均を表示 SELECT id, SUM(sales) AS ' 合計', AVG(sales) AS ' 平均' FROM sales_info GROUP BY id; ","5.2 グループごとに分けてから抽出（HAVING 句との融合） 21 Before sales_info id sales month A103 101 4 A102 54 5 A104 181 4 A101 184 4 A103 17 5 A101 300 5 A102 205 6 A104 93 5 A103 12 6 A107 87 6 After id 合計 平均 A101 484 0.242e3 A102 259 0.1295e3 A103 130 0.433333e2 A104 274 0.137e3 A107 87 0.87e2 5.2 グループごとに分けてから抽出（HAVING 句との融合） GROUP BY 句に加えて HAVING 句を使うと、グループに分けたものの中から、さらに HAVING 句で指定した条件のものだけを最終的に持っていく（操作する）ことができる。 After ：総売上が 200 以上の社員の売上情報のみを表示 SELECT id, SUM(sales) FROM sales_info GROUP BY id HAVING SUM(sales) >= 200; ","5.3 抽出してからグループに分ける（WHERE 句との融合） 22 Before sales_info id sales month A103 101 4 A102 54 5 A104 181 4 A101 184 4 A103 17 5 A101 300 5 A102 205 6 A104 93 5 A103 12 6 A107 87 6 After id SUM(sales) A101 484 A102 259 A104 274 5.3 抽出してからグループに分ける（WHERE 句との融合） WHERE 句と GROUP BY 句を併用すると、 WHERE 句で指定したレコードだけをグルー プに分けることができる。 例えば、平均演算の場合、件数が異なれば違う値が算出されるので、「絞り込んでから計 算する」or「計算してから絞り込む」の違いが重要となる。 After ：売上が 50 以上の取引を担当した社員の月平均売上を表示 SELECT id, AVG(sales) FROM sales_info WHERE sales >= 50 GROUP BY id ","5.4 グループ化してから並び替える（ORDER BY 句との融合） 23 Before sales_info id sales month A103 101 4 A102 54 5 A104 181 4 A101 184 4 A103 17 5 A101 300 5 A102 205 6 A104 93 5 A103 12 6 A107 87 6 After id AVG(sales) A101 0.242e3 A102 0.1295e3 A103 0.101e3 A104 0.137e3 A107 0.87e2 5.4 グループ化してから並び替える（ORDER BY 句との融合） After ：月平均売上が多い社員ランキングを表示 SELECT id, AVG(sales) FROM sales_info GROUP BY id ORDER BY AVG(sales) DESC; ","24 Before sales_info id sales month A103 101 4 A102 54 5 A104 181 4 A101 184 4 A103 17 5 A101 300 5 A102 205 6 A104 93 5 A103 12 6 A107 87 6 After id AVG(sales) A101 0.242e3 A104 0.137e3 A102 0.1295e3 A107 0.87e2 A103 0.433333e2 6 テーブルの結合 6.1 同じカラム構造のテーブルの結合 After ：別営業所も含めた全社員一覧を表示 SELECT * FROM employees_info UNION SELECT * FROM another_office_employees_info; ","6.1 同じカラム構造のテーブルの結合 25 Before employees_info id name age A101 富江 40 A102 安宮 28 A103 深沢 20 A104 東 23 A105 佐原 35 Before another_oﬃce_employees_info id name age A106 時雨 26 A107 白沢 24 A108 瀬崎 23 A109 大津 25 A110 芹川 27 After id name age A101 富江 40 A102 安宮 28 A103 深沢 20 A104 東 23 A105 佐原 35 A106 時雨 26 A107 白沢 24 A108 瀬崎 23 A109 大津 25 A110 芹川 27 After ：売上成績が優秀な社員と年長のベテラン社員のリストを表示 SELECT id FROM sales_info WHERE sales >= 200 UNION ","6.1 同じカラム構造のテーブルの結合 26 SELECT id FROM employees_info WHERE age >= 35; Before sales_info id sales month A103 101 4 A102 54 5 A104 181 4 A101 184 4 A103 17 5 A101 300 5 A102 205 6 A104 93 5 A103 12 6 A107 87 6 Before employees_info id name age A101 富江 40 A102 安宮 28 A103 深沢 20 A104 東 23 A105 佐原 35 After id A101 A102 A105 実は UNION による結合では、重複データを省くという作業が行われている。 UNION ALL を使うと、重複データもそのまま表示されるようになる。 ","6.1 同じカラム構造のテーブルの結合 27 After ：売上成績が優秀な社員と年長のベテラン社員のリストを表示（重複 許容） SELECT id FROM sales_info WHERE sales >= 200 UNION ALL SELECT id FROM employees_info WHERE age >= 35; Before sales_info id sales month A103 101 4 A102 54 5 A104 181 4 A101 184 4 A103 17 5 A101 300 5 A102 205 6 A104 93 5 A103 12 6 A107 87 6 Before employees_info id name age A101 富江 40 A102 安宮 28 A103 深沢 20 A104 東 23 A105 佐原 35 ","6.2 同じカラムをもつテーブルの結合１（一致レコードを抽出：内部結合） 28 After id A101 A102 A101 A105 6.2 同じカラムをもつテーブルの結合１（一致レコードを抽出：内部結合） After ：id が一致するレコードを横に繋げる（ON 使用） SELECT * FROM sales_info INNER JOIN employees_info ON sales_info.id = employees_info.id INNER は省略してもよい。 また、ON の代わりに USING を用いて、次のように書くこともできる。 After ：id が一致するレコードを横に繋げる（USING 使用） SELECT * FROM sales_info INNER JOIN employees_info USING(id) ","6.2 同じカラムをもつテーブルの結合１（一致レコードを抽出：内部結合） 29 Before sales_info id sales month A103 101 4 A102 54 5 A104 181 4 A101 184 4 A103 17 5 A101 300 5 A102 205 6 A104 93 5 A103 12 6 A107 87 6 Before employees_info id name age A101 富江 40 A102 安宮 28 A103 深沢 20 A104 東 23 A105 佐原 35 After id sales month name age A103 101 4 深沢 20 A102 54 5 安宮 28 A104 181 4 東 23 A101 184 4 富江 40 A103 17 5 深沢 20 A101 300 5 富江 40 A102 205 6 安宮 28 A104 93 5 東 23 A103 12 6 深沢 20 ","6.2 同じカラムをもつテーブルの結合１（一致レコードを抽出：内部結合） 30 After ：社員の ID・名前・売上を一覧で表示 SELECT s.id, e.name, s.sales FROM sales_info AS s INNER JOIN employees_info AS e ON s.id = e.id; Before sales_info id sales month A103 101 4 A102 54 5 A104 181 4 A101 184 4 A103 17 5 A101 300 5 A102 205 6 A104 93 5 A103 12 6 A107 87 6 Before employees_info id name age A101 富江 40 A102 安宮 28 A103 深沢 20 A104 東 23 A105 佐原 35 ","6.2 同じカラムをもつテーブルの結合１（一致レコードを抽出：内部結合） 31 After id name sales A103 深沢 101 A102 安宮 54 A104 東 181 A101 富江 184 A103 深沢 17 A101 富江 300 A102 安宮 205 A104 東 93 A103 深沢 12 After ：売上が 100 以上の社員の ID・名前・売上を一覧で表示 SELECT s.id AS ' 社員番号', e.name AS ' 氏名', s.sales AS ' 売上' FROM sales_info AS s INNER JOIN employees_info AS e USING (id) WHERE s.sales >= 100; ","6.2 同じカラムをもつテーブルの結合１（一致レコードを抽出：内部結合） 32 Before sales_info id sales month A103 101 4 A102 54 5 A104 181 4 A101 184 4 A103 17 5 A101 300 5 A102 205 6 A104 93 5 A103 12 6 A107 87 6 Before employees_info id name age A101 富江 40 A102 安宮 28 A103 深沢 20 A104 東 23 A105 佐原 35 After 社員番号 氏名 売上 A101 富江 184 A101 富江 300 A102 安宮 205 A103 深沢 101 A104 東 181 After ：社員の ID・名前・売上・出身を一覧で表示 SELECT s.id, e.name, n.prefecture FROM sales_info AS s ","6.2 同じカラムをもつテーブルの結合１（一致レコードを抽出：内部結合） 33 INNER JOIN employees_info AS e USING(id) INNER JOIN native_prefecture_info AS n USING(id); Before sales_info id sales month A103 101 4 A102 54 5 A104 181 4 A101 184 4 A103 17 5 A101 300 5 A102 205 6 A104 93 5 A103 12 6 A107 87 6 Before employees_info id name age A101 富江 40 A102 安宮 28 A103 深沢 20 A104 東 23 A105 佐原 35 ","6.3 同じカラムをもつテーブルの結合２（すべて抽出：外部結合） 34 Before native_prefecture_info id prefecture A101 東京都 A102 埼玉県 A103 神奈川県 A104 北海道 A105 静岡県 After id name prefecture A103 深沢 神奈川県 A102 安宮 埼玉県 A104 東 北海道 A101 富江 東京都 A103 深沢 神奈川県 A101 富江 東京都 A102 安宮 埼玉県 A104 東 北海道 A103 深沢 神奈川県 6.3 同じカラムをもつテーブルの結合２（すべて抽出：外部結合） 6.3.1 外部結合の種類 外部結合では、キーが一致するレコードだけではなく、 • 左外部結合なら、FROM の後に指定したテーブルの全レコード • 右外部結合なら、INNER JOIN の後に指定したテーブルの全レコード を表示する。 Before ：集合 A と集合 B を表すテーブル CREATE TABLE set_A( id INTEGER, name VARCHAR(5) ","6.3 同じカラムをもつテーブルの結合２（すべて抽出：外部結合） 35 ); INSERT INTO set_A VALUES (1, ' 富江'); INSERT INTO set_A VALUES (2, ' 深沢'); INSERT INTO set_A VALUES (3, ' 東'); CREATE TABLE set_B( id INTEGER, name VARCHAR(5) ); INSERT INTO set_B VALUES (1, ' 富江'); INSERT INTO set_B VALUES (2, ' 深沢'); INSERT INTO set_B VALUES (4, ' 安登'); SELECT * FROM set_A; SELECT * FROM set_B; After ：左外部結合の例 SELECT A.id AS A_id, B.name AS B_name FROM set_A AS A LEFT OUTER JOIN set_B AS B USING(id); ","6.3 同じカラムをもつテーブルの結合２（すべて抽出：外部結合） 36 Before set_A id name 1 富江 2 深沢 3 東 Before set_B id name 1 富江 2 深沢 4 安登 After A_id B_name 1 富江 2 深沢 3 After ：右外部結合の例 SELECT A.id AS A_id, B.name AS B_name FROM set_A AS A RIGHT OUTER JOIN set_B AS B USING(id); ","6.3 同じカラムをもつテーブルの結合２（すべて抽出：外部結合） 37 Before set_A id name 1 富江 2 深沢 3 東 Before set_B id name 1 富江 2 深沢 4 安登 After A_id B_name 1 富江 2 深沢 安登 完全外部結合では、キーが一致するレコードだけではなく、 • FROM の後に指定したテーブルの全レコード • INNER JOIN の後に指定したテーブルの全レコード の両方を表示する。 通常、完全外部結合は FULL OUTER JOIN を用いるが、MySQL ではサポートされていな いため、 左外部結合の結果 UNION 右外部結合の結果 という代替手法を用いる。 ","6.3 同じカラムをもつテーブルの結合２（すべて抽出：外部結合） 38 After ：完全外部結合の例 SELECT A.id AS A_id, B.name AS B_name FROM set_A AS A LEFT OUTER JOIN set_B AS B USING(id) UNION SELECT A.id AS A_id, B.name AS B_name FROM set_A AS A RIGHT OUTER JOIN set_B AS B USING(id) Before set_A id name 1 富江 2 深沢 3 東 2 id name 1 富江 2 深沢 4 安登 ","6.3 同じカラムをもつテーブルの結合２（すべて抽出：外部結合） 39 After A_id B_name 1 富江 2 深沢 3 安登 6.3.2 差集合を求める After ：A に含まれるものから、B に含まれるものを除いて表示（差集合 A − B） SELECT A.id AS A_id, A.name AS A_name FROM set_A AS A LEFT OUTER JOIN set_B AS B USING(id) WHERE B.name IS NULL; Before set_A id name 1 富江 2 深沢 3 東 Before set_B id name 1 富江 2 深沢 4 安登 ","6.3 同じカラムをもつテーブルの結合２（すべて抽出：外部結合） 40 After A_id A_name 3 東 After ：B に含まれるものから、A に含まれるものを除いて表示（差集合 B − A） SELECT B.id AS B_id, B.name AS B_name FROM set_A AS A RIGHT OUTER JOIN set_B AS B USING(id) WHERE A.name IS NULL; Before set_A id name 1 富江 2 深沢 3 東 Before set_B id name 1 富江 2 深沢 4 安登 After B_id B_name 4 安登 ","6.3 同じカラムをもつテーブルの結合２（すべて抽出：外部結合） 41 6.3.3 排他的和集合を求める After ：排他的和集合 (A ∪ B) − (A ∩ B) の表示 SELECT COALESCE(A.id, B.id) AS id, COALESCE(A.name, B.name) AS name FROM set_A AS A LEFT OUTER JOIN set_B AS B USING(id) WHERE A.name IS NULL OR B.name IS NULL UNION SELECT COALESCE(A.id, B.id) AS id, COALESCE(A.name, B.name) AS name FROM set_A AS A RIGHT OUTER JOIN set_B AS B USING(id) WHERE A.name IS NULL OR B.name IS NULL ","6.3 同じカラムをもつテーブルの結合２（すべて抽出：外部結合） 42 Before set_A id name 1 富江 2 深沢 3 東 Before set_B id name 1 富江 2 深沢 4 安登 After id name 3 東 4 安登 E”x´a‹m¯p˜l´e クロス表の作成 Before ：受講済み研修講座をまとめたテーブル CREATE TABLE course_taken( student VARCHAR(5), course VARCHAR(20) ); INSERT INTO course_taken VALUES (' 富江', 'SQL 入門'); INSERT INTO course_taken VALUES (' 富江', 'UNIX 基礎'); ","6.3 同じカラムをもつテーブルの結合２（すべて抽出：外部結合） 43 INSERT INTO course_taken VALUES (' 深沢', 'SQL 入門'); INSERT INTO course_taken VALUES (' 東', 'SQL 入門'); INSERT INTO course_taken VALUES (' 東', 'Java 中級'); INSERT INTO course_taken VALUES (' 安登', 'UNIX 基礎'); INSERT INTO course_taken VALUES (' 佐原', 'SQL 入門'); SELECT * FROM course_taken; 1. 全員の名前を集めたテーブル 2. SQL 入門受講者の名前を集めたテーブル 3. UNIX 基礎受講者の名前を集めたテーブル 4. Java 中級受講者の名前を集めたテーブル を作り、これらをこの順番で外部結合させる。 After ：受講済み研修講座テーブルをクロス表に整形して表示 SELECT al.student AS '', CASE WHEN sq.student IS NOT NULL THEN ' 済' ELSE NULL END AS 'SQL 入門', CASE WHEN un.student IS NOT NULL THEN ' 済' ","6.3 同じカラムをもつテーブルの結合２（すべて抽出：外部結合） 44 ELSE NULL END AS 'UNIX 基礎', CASE WHEN ja.student IS NOT NULL THEN ' 済' ELSE NULL END AS 'Java 中級' FROM ( SELECT DISTINCT student FROM course_taken ) AS al LEFT OUTER JOIN ( SELECT student FROM course_taken WHERE course = 'SQL 入門' ) AS sq ON al.student = sq.student LEFT OUTER JOIN ( SELECT student FROM course_taken WHERE course = 'UNIX 基礎' ) AS un ON al.student = un.student LeFT OUTER JOIN ( SELECT student FROM course_taken WHERE course = 'Java 中級' ) AS ja ON al.student = ja.student; ","6.3 同じカラムをもつテーブルの結合２（すべて抽出：外部結合） 45 Before course_taken student course 富江 SQL 入門 富江 UNIX 基礎 深沢 SQL 入門 東 SQL 入門 東 Java 中級 安登 UNIX 基礎 佐原 SQL 入門 After SQL 入門 UNIX 基礎 Java 中級 東 済 済 富江 済 済 安登 済 深沢 済 佐原 済 E”x´a‹m¯p˜l´e 同種の情報を表す複数の列を 1 列にまとめる ","6.3 同じカラムをもつテーブルの結合２（すべて抽出：外部結合） 46 Before ：社員の子供情報をまとめたテーブル CREATE TABLE children_of_employees( employee VARCHAR(5), child_1 VARCHAR(5), child_2 VARCHAR(5), child_3 VARCHAR(5) ); INSERT INTO children_of_employees VALUES (' 富江', ' 蓮', ' 澄', ' 了'); , → INSERT INTO children_of_employees (employee, child_1, child_2) VALUES (' 深沢', ' 彩雪', ' 彩夜'); , → INSERT INTO children_of_employees (employee, child_1) VALUES (' 東', ' 琴葉'); , → INSERT INTO children_of_employees (employee) VALUES (' 安登'); SELECT * FROM children_of_employees; 子供の名前を一覧にしたビュー CREATE VIEW children_name(child) AS SELECT child_1 FROM children_of_employees UNION SELECT child_2 FROM children_of_employees UNION SELECT child_3 FROM children_of_employees; SELECT * FROM children_name; ","6.3 同じカラムをもつテーブルの結合２（すべて抽出：外部結合） 47 child 蓮 彩雪 琴葉 澄 彩夜 了 After ：子供情報を一列にまとめて表示 SELECT e.employee, c.child FROM children_of_employees AS e LEFT OUTER JOIN children_name AS c ON c.child IN (e.child_1, e.child_2, e.child_3) ORDER BY e.employee; Before children_of_employees employee child_1 child_2 child_3 富江 蓮 澄 了 深沢 彩雪 彩夜 東 琴葉 安登 ","6.3 同じカラムをもつテーブルの結合２（すべて抽出：外部結合） 48 After employee child 安登 富江 蓮 富江 澄 富江 了 東 琴葉 深沢 彩雪 深沢 彩夜 E”x´a‹m¯p˜l´e 入れ子の表を作成 Before ：年齢階級定義・性別コード定義・人口構成を表すテーブル群 CREATE TABLE age_class_definitions ( age_class INT, age_range VARCHAR(10) ); INSERT INTO age_class_definitions VALUES (1, '21～30 歳'); INSERT INTO age_class_definitions VALUES (2, '31～40 歳'); INSERT INTO age_class_definitions VALUES (3, '41～50 歳'); CREATE TABLE sex_code_definitions ( sex_code CHAR(1), sex CHAR(1) ","6.3 同じカラムをもつテーブルの結合２（すべて抽出：外部結合） 49 ); INSERT INTO sex_code_definitions VALUES ('m', ' 男'); INSERT INTO sex_code_definitions VALUES ('f', ' 女'); CREATE TABLE demographic_composition ( prefecture VARCHAR(5), age_class INT, sex_code CHAR(1), population INT ); INSERT INTO demographic_composition VALUES (' 秋田', 1, 'm', 400); INSERT INTO demographic_composition VALUES (' 秋田', 3, 'm', 1000); INSERT INTO demographic_composition VALUES (' 秋田', 1, 'f', 800); INSERT INTO demographic_composition VALUES (' 秋田', 3, 'f', 1000); INSERT INTO demographic_composition VALUES (' 青森', 1, 'm', 700); INSERT INTO demographic_composition VALUES (' 青森', 1, 'f', 500); INSERT INTO demographic_composition VALUES (' 青森', 3, 'f', 800); INSERT INTO demographic_composition VALUES (' 東京', 1, 'm', 900); INSERT INTO demographic_composition VALUES (' 東京', 1, 'f', 1500); INSERT INTO demographic_composition ","6.3 同じカラムをもつテーブルの結合２（すべて抽出：外部結合） 50 VALUES (' 東京', 3, 'f', 1200); INSERT INTO demographic_composition VALUES (' 千葉', 1, 'm', 900); INSERT INTO demographic_composition VALUES (' 千葉', 1, 'f', 1000); INSERT INTO demographic_composition VALUES (' 千葉', 3, 'f', 900); SELECT * FROM age_class_definitions; SELECT * FROM sex_code_definitions; SELECT * FROM demographic_composition; 表側（左側の見出しカラム） SELECT age_class, sex_code FROM age_class_definitions CROSS JOIN sex_code_definitions; age_class sex_code 1 m 1 f 2 m 2 f 3 m 3 f ","6.3 同じカラムをもつテーブルの結合２（すべて抽出：外部結合） 51 表頭（上部の見出し部分）とデータ部分 SELECT age_class AS ' 年齢階級', sex_code AS ' 性別', SUM( CASE WHEN prefecture IN (' 青森', ' 秋田') THEN population ELSE NULL END ) AS ' 東北の人口', SUM( CASE WHEN prefecture IN (' 東京', ' 千葉') THEN population ELSE NULL END ) AS ' 関東の人口' FROM demographic_composition GROUP BY age_class, sex_code ORDER BY age_class ASC, sex_code DESC; ","6.3 同じカラムをもつテーブルの結合２（すべて抽出：外部結合） 52 年齢階級 性別 東北の人口 関東の人口 1 m 1100 1800 1 f 1300 2500 3 m 1000 3 f 1800 2100 上記の 2 つのテーブルを登場順に左外部結合すれば、目的の表が得られる。 After ：人口構成テーブルを東北・関東に分けて集計し、入れ子の表に整形し て表示 SELECT leftTitle.age_class AS ' 年代', leftTitle.sex_code AS ' 性別', data.tohoku AS ' 東北の人口', data.kanto AS ' 関東の人口' FROM ( SELECT age_class, sex_code FROM age_class_definitions CROSS JOIN sex_code_definitions ) AS leftTitle LEFT OUTER JOIN ( SELECT age_class, sex_code, SUM( ","6.3 同じカラムをもつテーブルの結合２（すべて抽出：外部結合） 53 CASE WHEN prefecture IN (' 青森', ' 秋田') THEN population ELSE NULL END ) AS tohoku, SUM( CASE WHEN prefecture IN (' 東京', ' 千葉') THEN population ELSE NULL END ) AS kanto FROM demographic_composition GROUP BY age_class, sex_code ORDER BY age_class ASC, sex_code DESC ) AS data ON leftTitle.age_class = data.age_class AND leftTitle.sex_code = data.sex_code; ","6.3 同じカラムをもつテーブルの結合２（すべて抽出：外部結合） 54 Before age_class_definitions age_class age_range 1 21～30 歳 2 31～40 歳 3 41～50 歳 Before sex_code_definitions sex_code sex m 男 f 女 Before demographic_composition prefecture age_class sex_code population 秋田 1 m 400 秋田 3 m 1000 秋田 1 f 800 秋田 3 f 1000 青森 1 m 700 青森 1 f 500 青森 3 f 800 東京 1 m 900 東京 1 f 1500 東京 3 f 1200 千葉 1 m 900 千葉 1 f 1000 千葉 3 f 900 ","6.3 同じカラムをもつテーブルの結合２（すべて抽出：外部結合） 55 After 年代 性別 東北の人口 関東の人口 1 m 1100 1800 1 f 1300 2500 2 m 2 f 3 m 1000 3 f 1800 2100 E”x´a‹m¯p˜l´e 売れた個数を集計して帳票を作成 Before ：PC ショップの売上履歴と商品一覧 CREATE TABLE PCshops_items( item_number INTEGER, item VARCHAR(20) ); INSERT INTO PCshops_items VALUES ('10', 'SD カード'); INSERT INTO PCshops_items VALUES ('20', 'CD-R'); INSERT INTO PCshops_items VALUES ('30', 'USB メモリ'); INSERT INTO PCshops_items VALUES ('40', 'DVD'); CREATE TABLE PCshop_sales_history( sale_date DATE, item_number INTEGER, ","6.3 同じカラムをもつテーブルの結合２（すべて抽出：外部結合） 56 quantity INTEGER ); INSERT INTO PCshop_sales_history VALUES ('2018-10-01', 10, 4); INSERT INTO PCshop_sales_history VALUES ('2018-10-01', 20, 10); INSERT INTO PCshop_sales_history VALUES ('2018-10-01', 30, 3); INSERT INTO PCshop_sales_history VALUES ('2018-10-03', 10, 32); INSERT INTO PCshop_sales_history VALUES ('2018-10-03', 30, 12); INSERT INTO PCshop_sales_history VALUES ('2018-10-04', 20, 22); INSERT INTO PCshop_sales_history VALUES ('2018-10-04', 30, 7); SELECT * FROM PCshops_items; SELECT * FROM PCshop_sales_history; After ：商品ごとに総計でいくつ売れたかを調べる帳票の表示（売れていない 商品も表示） SELECT i.item_number AS ' 商品', SUM(s.quantity) AS ' 売れた個数' FROM PCshops_items AS i LEFT OUTER JOIN PCshop_sales_history AS s USING(item_number) GROUP BY i.item_number; ","6.3 同じカラムをもつテーブルの結合２（すべて抽出：外部結合） 57 Before PCshop_items item_number item 10 SD カード 20 CD-R 30 USB メモリ 40 DVD Before PCshop_sales_history sale_date item_number quantity 2018-10-01 10 4 2018-10-01 20 10 2018-10-01 30 3 2018-10-03 10 32 2018-10-03 30 12 2018-10-04 20 22 2018-10-04 30 7 After 商品 売れた個数 10 36 20 32 30 22 40 ","6.4 同じ名前のテーブルの結合（自己結合） 58 6.4 同じ名前のテーブルの結合（自己結合） 自己結合には特定の構文があるわけではなく、これまで登場した結合の構文を同名のテー ブルに適用すれば、それは自己結合になる。 6.4.1 順列と組合せの表現 After ：重複順列の一覧を表示（交差結合による自己結合） SELECT e1.id AS e1_id, e2.id AS e2_id FROM employees_info AS e2 CROSS JOIN employees_info AS e1 Before employees_info id name age A101 富江 40 A102 安宮 28 A103 深沢 20 A104 東 23 A105 佐原 35 Before employees_info id name age A101 富江 40 A102 安宮 28 A103 深沢 20 A104 東 23 A105 佐原 35 ","6.4 同じ名前のテーブルの結合（自己結合） 59 After e1_id e2_id A101 A101 A101 A102 A101 A103 A101 A104 A101 A105 A102 A101 A102 A102 A102 A103 A102 A104 A102 A105 A103 A101 A103 A102 A103 A103 A103 A104 A103 A105 A104 A101 A104 A102 A104 A103 A104 A104 A104 A105 A105 A101 A105 A102 A105 A103 A105 A104 A105 A105 ","6.4 同じ名前のテーブルの結合（自己結合） 60 After ：順列（重複を除いたもの）の一覧を表示 SELECT e1.id AS e1_id, e2.id AS e2_id FROM employees_info AS e2 INNER JOIN employees_info AS e1 ON e1.id <> e2.id Before employees_info id name age A101 富江 40 A102 安宮 28 A103 深沢 20 A104 東 23 A105 佐原 35 Before employees_info id name age A101 富江 40 A102 安宮 28 A103 深沢 20 A104 東 23 A105 佐原 35 ","6.4 同じ名前のテーブルの結合（自己結合） 61 After e1_id e2_id A101 A102 A101 A103 A101 A104 A101 A105 A102 A101 A102 A103 A102 A104 A102 A105 A103 A101 A103 A102 A103 A104 A103 A105 A104 A101 A104 A102 A104 A103 A104 A105 A105 A101 A105 A102 A105 A103 A105 A104 After ：組合せの一覧を表示 SELECT e1.id AS e1_id, e2.id AS e2_id FROM ","6.4 同じ名前のテーブルの結合（自己結合） 62 employees_info AS e1 INNER JOIN employees_info AS e2 WHERE e1.id < e2.id Before employees_info id name age A101 富江 40 A102 安宮 28 A103 深沢 20 A104 東 23 A105 佐原 35 Before employees_info id name age A101 富江 40 A102 安宮 28 A103 深沢 20 A104 東 23 A105 佐原 35 After e1_id e2_id A101 A102 A101 A103 A101 A104 A101 A105 A102 A103 A102 A104 A102 A105 A103 A104 A103 A105 A104 A105 ","6.4 同じ名前のテーブルの結合（自己結合） 63 After ：3 つ選び取った組合せの一覧を表示 ELECT e1.id AS e1_id, e2.id AS e2_id, e3.id AS e3_id FROM employees_info AS e1 INNER JOIN employees_info AS e2 ON e1.id < e2.id INNER JOIN employees_info AS e3 ON e2.id < e3.id ORDER BY e1.id, e2.id, e3.id Before employees_info id name age A101 富江 40 A102 安宮 28 A103 深沢 20 A104 東 23 A105 佐原 35 Before employees_info id name age A101 富江 40 A102 安宮 28 A103 深沢 20 A104 東 23 A105 佐原 35 ","6.4 同じ名前のテーブルの結合（自己結合） 64 After e1_id e2_id e3_id A101 A102 A103 A101 A102 A104 A101 A102 A105 A101 A103 A104 A101 A103 A105 A101 A104 A105 A102 A103 A104 A102 A103 A105 A102 A104 A105 A103 A104 A105 E”x´a‹m¯p˜l´e 値段は同じだが、商品名が違う商品レコードの抽出 Before ：商品一覧を表すテーブルの作成 CREATE TABLE products( name VARCHAR(10), price INTEGER(250) ); INSERT INTO products VALUES (' りんご', 50); INSERT INTO products VALUES (' みかん', 100); INSERT INTO products VALUES (' ぶどう', 50); INSERT INTO products VALUES (' スイカ', 80); ","6.4 同じ名前のテーブルの結合（自己結合） 65 INSERT INTO products VALUES (' レモン', 30); INSERT INTO products VALUES (' いちご', 100); INSERT INTO products VALUES (' バナナ', 100); After ：同じ値段だが、商品名が異なるレコードを表示 SELECT DISTINCT p1.name, p1.price FROM products AS p1 INNER JOIN products AS p2 ON p1.price = p2.price AND p1.name <> p2.name ORDER BY p1.price Before products name price りんご 50 みかん 100 ぶどう 50 スイカ 80 レモン 30 いちご 100 バナナ 100 Before products name price りんご 50 みかん 100 ぶどう 50 スイカ 80 レモン 30 いちご 100 バナナ 100 ","6.4 同じ名前のテーブルの結合（自己結合） 66 After name price ぶどう 50 りんご 50 いちご 100 バナナ 100 みかん 100 E”x´a‹m¯p˜l´e ランキングの作成 自分より高い値段の商品の個数が、そのまま順位となる。 After ：値段の高い順ランキングを表示 SELECT p1.name, MAX(p1.price) AS price, COUNT(p2.name) + 1 AS rank FROM products AS p1 LEFT OUTER JOIN products AS p2 ON p1.price < p2.price GROUP BY p1.name ORDER BY rank; ","67 Before products name price りんご 50 みかん 100 ぶどう 50 スイカ 80 レモン 30 いちご 100 バナナ 100 Before products name price りんご 50 みかん 100 ぶどう 50 スイカ 80 レモン 30 いちご 100 バナナ 100 After name price rank いちご 100 1 バナナ 100 1 みかん 100 1 スイカ 80 4 りんご 50 5 ぶどう 50 5 レモン 30 7 7 サブクエリ（副問い合わせ） 7.1 値を返すサブクエリ 売上の最大値を取得してから、売上が最大値のレコードを選択する。 ","7.1 値を返すサブクエリ 68 After ：最大の値をもつレコードを表示 SELECT * FROM sales_info WHERE sales IN ( SELECT MAX(sales) FROM sales_info ); Before sales_info id sales month A103 101 4 A102 54 5 A104 181 4 A101 184 4 A103 17 5 A101 300 5 A102 205 6 A104 93 5 A103 12 6 A107 87 6 After id sales month A101 300 5 After ：平均年齢以上の年齢の社員情報を一覧で表示 SELECT * FROM employees_info WHERE age >= ( SELECT AVG(age) FROM employees_info ); ","7.2 カラムを返すサブクエリ 69 Before employees_info id name age A101 富江 40 A102 安宮 28 A103 深沢 20 A104 東 23 A105 佐原 35 After id name age A101 富江 40 A105 佐原 35 7.2 カラムを返すサブクエリ After ：200 以上の売上をもつ社員名を表示 SELECT * FROM employees_info WHERE id IN ( SELECT id FROM sales_info WHERE sales >= 200 ); ","7.2 カラムを返すサブクエリ 70 Before sale_info id sales month A103 101 4 A102 54 5 A104 181 4 A101 184 4 A103 17 5 A101 300 5 A102 205 6 A104 93 5 A103 12 6 A107 87 6 Before employees_info id name age A101 富江 40 A102 安宮 28 A103 深沢 20 A104 東 23 A105 佐原 35 After id name age A101 富江 40 A102 安宮 28 E”x´a‹m¯p˜l´e ランキングの作成 連続番号機能をつけた空のテーブルに、売上の順に並べたレコードを挿入していくと、売 上の順に連続番号が振られ、ランキングを作成することができる。 ","7.2 カラムを返すサブクエリ 71 売上情報テーブルと同構造のテーブルを作成 CREATE TABLE sales_ranking LIKE sales_info; 作成したテーブルにランク用カラムを追加 ALTER TABLE sales_ranking ADD rank INT AUTO_INCREMENT PRIMARY KEY; 売上順に並べたレコードを挿入 INSERT INTO sales_ranking ( id, sales, month )( SELECT id, sales, month FROM sales_info ORDER BY sales DESC ); ランキングテーブルを表示 SELECT * FROM sales_ranking; ","72 After id sales month rank A101 300 5 1 A102 205 6 2 A101 184 4 3 A104 181 4 4 A103 101 4 5 A104 93 5 6 A107 87 6 7 A102 54 5 8 A103 17 5 9 A103 12 6 10 8 CASE 式による集計 8.1 既存のコード体系を新しい体系に変換して集計 E”x´a‹m¯p˜l´e 県ごとの人口を地方ごとに再分類 県ごとに人口をまとめたテーブルの作成 CREATE TABLE population_by_prefecture ( prefecture_name VARCHAR(4), ","8.1 既存のコード体系を新しい体系に変換して集計 73 population INT ); INSERT INTO population_by_prefecture VALUES (' 徳島', 100); INSERT INTO population_by_prefecture VALUES (' 香川', 200); INSERT INTO population_by_prefecture VALUES (' 愛媛', 150); INSERT INTO population_by_prefecture VALUES (' 高知', 200); INSERT INTO population_by_prefecture VALUES (' 福岡', 300); INSERT INTO population_by_prefecture VALUES (' 佐賀', 100); INSERT INTO population_by_prefecture VALUES (' 長崎', 200); INSERT INTO population_by_prefecture VALUES (' 東京', 400); INSERT INTO population_by_prefecture VALUES (' 群馬', 50); Before ：県ごとの人口を表示 SELECT * FROM population_by_prefecture ","8.1 既存のコード体系を新しい体系に変換して集計 74 After ：地方ごとの人口を表示 SELECT CASE prefecture_name WHEN ' 徳島' THEN ' 四国' WHEN ' 香川' THEN ' 四国' WHEN ' 愛媛' THEN ' 四国' WHEN ' 高知' THEN ' 四国' WHEN ' 福岡' THEN ' 九州' WHEN ' 佐賀' THEN ' 九州' WHEN ' 長崎' THEN ' 九州' ELSE ' その他' END AS district, SUM(population) FROM `population_by_prefecture` GROUP BY district; ","8.2 異なる条件の集計を一つの SQL で行う 75 Before population_by_prefecture prefecture_name population 徳島 100 香川 200 愛媛 150 高知 200 福岡 300 佐賀 100 長崎 200 東京 400 群馬 50 After district SUM(population) その他 450 九州 600 四国 650 8.2 異なる条件の集計を一つの SQL で行う E”x´a‹m¯p˜l´e 一次元表を二次元表に整形 ","8.2 異なる条件の集計を一つの SQL で行う 76 一次元表の形で県・性別ごとの人口を表すテーブルを作成 CREATE TABLE population_by_prefecture_and_sex ( prefecture_name VARCHAR(4), sex INT, population INT ); INSERT INTO population_by_prefecture_and_sex VALUES (' 徳島', 1, 60); INSERT INTO population_by_prefecture_and_sex VALUES (' 徳島', 2, 40); INSERT INTO population_by_prefecture_and_sex VALUES (' 香川', 1, 100); INSERT INTO population_by_prefecture_and_sex VALUES (' 香川', 2, 100); INSERT INTO population_by_prefecture_and_sex VALUES (' 愛媛', 1, 100); INSERT INTO population_by_prefecture_and_sex VALUES (' 愛媛', 2, 50); INSERT INTO population_by_prefecture_and_sex VALUES (' 高知', 1, 100); INSERT INTO population_by_prefecture_and_sex VALUES (' 高知', 2, 100); INSERT INTO population_by_prefecture_and_sex VALUES (' 福岡', 1, 100); INSERT INTO population_by_prefecture_and_sex VALUES (' 福岡', 2, 200); INSERT INTO population_by_prefecture_and_sex VALUES (' 佐賀', 1, 20); ","8.2 異なる条件の集計を一つの SQL で行う 77 INSERT INTO population_by_prefecture_and_sex VALUES (' 佐賀', 2, 80); INSERT INTO population_by_prefecture_and_sex VALUES (' 長崎', 1, 125); INSERT INTO population_by_prefecture_and_sex VALUES (' 長崎', 1, 125); INSERT INTO population_by_prefecture_and_sex VALUES (' 東京', 1, 250); INSERT INTO population_by_prefecture_and_sex VALUES (' 東京', 1, 150); Before ：県・性別ごとの人口を表示 SELECT * FROM population_by_prefecture_and_sex After ：各県に対して男女別に人口を表示 SELECT prefecture_name, SUM( CASE WHEN sex = 1 THEN population ELSE 0 END ) AS number_of_man, SUM( CASE WHEN sex = 2 THEN population ","8.2 異なる条件の集計を一つの SQL で行う 78 ELSE 0 END ) AS number_of_woman FROM population_by_prefecture_and_sex GROUP BY prefecture_name Before population_by_prefecture_and_sex prefecture_name sex population 徳島 1 60 徳島 2 40 香川 1 100 香川 2 100 愛媛 1 100 愛媛 2 50 高知 1 100 高知 2 100 福岡 1 100 福岡 2 200 佐賀 1 20 佐賀 2 80 長崎 1 125 長崎 1 125 東京 1 250 東京 1 150 ","8.3 条件を分岐させた UPDATE 79 After prefecture_name number_of_man number_of_woman 佐賀 20 80 徳島 60 40 愛媛 100 50 東京 400 0 福岡 100 200 長崎 250 0 香川 100 100 高知 100 100 8.3 条件を分岐させた UPDATE E”x´a‹m¯p˜l´e 現在の給料によって減給か昇給かを決める 各社員の給料を表すテーブルを作成 CREATE TABLE salaries ( employee_name VARCHAR(5), salary INT ); INSERT INTO salaries VALUES (' 相田', 300000); INSERT INTO salaries VALUES (' 神崎', 270000); INSERT INTO salaries VALUES (' 木村', 220000); INSERT INTO salaries VALUES (' 斎藤', 290000); ","8.3 条件を分岐させた UPDATE 80 Before ：現在の月給を表示 SELECT * FROM salaries このテーブルを、次のような条件で更新する。 • 現在の給料が 30 万円以上の社員は、10% 減給する • 現在の給料が 25 万以上 28 万未満の社員は、20% 昇給する テーブルを変更 UPDATE salaries SET salary = CASE WHEN salary >= 300000 THEN salary * 0.9 WHEN salary >= 250000 AND salary < 280000 THEN salary * 1.2 ELSE salary END; After ：減給 or 昇給後の月給を表示 SELECT * FROM salaries ","8.4 テーブル同士のマッチング 81 Before salaries employee_name salary 相田 300000 神崎 270000 木村 220000 斎藤 290000 After employee_name salary 相田 270000 神崎 324000 木村 220000 斎藤 290000 8.4 テーブル同士のマッチング E”x´a‹m¯p˜l´e 2 つのテーブルを id で結合してクロス表を作る テーブルを作成 CREATE TABLE all_courses( course_id INT, name VARCHAR(20) ); CREATE TABLE open_courses( month INT, course_id INT ); INSERT INTO all_courses VALUES (1, ' 電磁気学'); ","8.4 テーブル同士のマッチング 82 INSERT INTO all_courses VALUES (2, ' 力学'); INSERT INTO all_courses VALUES (3, ' 数値解析'); INSERT INTO all_courses VALUES (4, ' 量子力学'); INSERT INTO open_courses VALUES (201806, 1); INSERT INTO open_courses VALUES (201806, 3); INSERT INTO open_courses VALUES (201806, 4); INSERT INTO open_courses VALUES (201807, 4); INSERT INTO open_courses VALUES (201808, 2); INSERT INTO open_courses VALUES (201806, 4); Before ：講座一覧テーブルと開講スケジュールテーブルをそれぞれ表示 SELECT * FROM all_courses; SELECT * FROM open_courses; After ：各月の開講状況が一目でわかるクロス表を表示（IN 述語を使用） SELECT name, CASE WHEN course_id IN ( SELECT course_id FROM open_courses WHERE month = 201806 ) THEN 'Open' ELSE 'Close' END As '6 月', CASE WHEN course_id IN ( ","8.4 テーブル同士のマッチング 83 SELECT course_id FROM open_courses WHERE month = 201807 ) THEN 'Open' ELSE 'Close' END As '7 月', CASE WHEN course_id IN ( SELECT course_id FROM open_courses WHERE month = 201808 ) THEN 'Open' ELSE 'Close' END As '8 月' FROM all_courses; After ：各月の開講状況が一目でわかるクロス表を表示（EXISTS 述語を使用） SELECT name, CASE WHEN EXISTS ( SELECT course_id FROM open_courses AS open WHERE month = 201806 AND open.course_id = allc.course_id ) THEN ","8.4 テーブル同士のマッチング 84 'Open' ELSE 'Close' END AS '6 月', CASE WHEN EXISTS ( SELECT course_id FROM open_courses AS open WHERE month = 201807 AND open.course_id = allc.course_id ) THEN 'Open' ELSE 'Close' END AS '7 月', CASE WHEN EXISTS ( SELECT course_id FROM open_courses AS open WHERE month = 201808 AND open.course_id = allc.course_id ) THEN 'Open' ELSE 'Close' END AS '8 月' FROM all_courses AS allc; ","8.5 CASE 式の中で集約関数を使う 85 Before all_courses course_id name 1 電磁気学 2 力学 3 数値解析 4 量子力学 Before open_courses month course_id 201806 1 201806 3 201806 4 201807 4 201808 2 201806 4 After name 6 月 7 月 8 月 電磁気学 Open Close Close 力学 Close Close Open 数値解析 Open Close Close 量子力学 Open Open Close 8.5 CASE 式の中で集約関数を使う E”x´a‹m¯p˜l´e 複数のデータから主なものを抽出する ","8.5 CASE 式の中で集約関数を使う 86 テーブルの作成 CREATE TABLE student_club( student_id INT, club_id INT, club_name VARCHAR(20), main_club_flug VARCHAR(1) ); INSERT INTO student_club VALUES (100, 1, ' 野球', 'Y'); INSERT INTO student_club VALUES (100, 2, ' 吹奏楽', 'N'); INSERT INTO student_club VALUES (200, 2, ' 吹奏楽', 'N'); INSERT INTO student_club VALUES (200, 3, ' バドミントン', 'Y'); INSERT INTO student_club VALUES (200, 4, ' サッカー', 'N'); INSERT INTO student_club VALUES (300, 4, ' サッカー', 'N'); INSERT INTO student_club VALUES (400, 5, ' 水泳', 'N'); INSERT INTO student_club VALUES (500, 6, ' 囲碁', 'N'); Before ：各生徒の所属クラブを全て表示 SELECT * FROM student_club このテーブルから、次のような条件でデータを抽出する。 • 1 つだけのクラブに所属している学生については、 そのクラブ ID を取得 • 複数のクラブに所属している学生については、 メインに活動しているクラブ（Y）の ID を取得 ","8.5 CASE 式の中で集約関数を使う 87 After ：各生徒がメインに活動しているクラブを表示 SELECT student_id, CASE WHEN COUNT(*) = 1 THEN MAX(club_id) ELSE MAX( CASE WHEN main_club_flug = 'Y' THEN club_id ELSE NULL END ) END AS main_club FROM student_club GROUP BY student_id; ","88 Before student_club student_id club_id club_name main_club_flug 100 1 野球 Y 100 2 吹奏楽 N 200 2 吹奏楽 N 200 3 バドミントン Y 200 4 サッカー N 300 4 サッカー N 400 5 水泳 N 500 6 囲碁 N After student_id main_club 100 1 200 3 300 4 400 5 500 6 9 「存在」と「全て」の扱い 9.1 テーブルに存在するデータの抽出 ","9.1 テーブルに存在するデータの抽出 89 E”x´a‹m¯p˜l´e 売上のある社員を検索 After ：売上のある（売上情報テーブルに載っている）社員を表示 SELECT * FROM employees_info AS e WHERE EXISTS ( SELECT * FROM sales_info AS s WHERE s.id = e.id ); Before sales_info id sales month A103 101 4 A102 54 5 A104 181 4 A101 184 4 A103 17 5 A101 300 5 A102 205 6 A104 93 5 A103 12 6 A107 87 6 Before employees_info id name age A101 富江 40 A102 安宮 28 A103 深沢 20 A104 東 23 A105 佐原 35 ","9.2 テーブルに存在しないデータの抽出 90 After id name age A101 富江 40 A102 安宮 28 A103 深沢 20 A104 東 23 9.2 テーブルに存在しないデータの抽出 E”x´a‹m¯p˜l´e 出席者リストから欠席者リストを作成 Before ：会合の出席者を記録したテーブルを作成・表示 CREATE TABLE attendees_at_meeting( meeting VARCHAR(10), attendee VARCHAR(10) ); INSERT INTO attendees_at_meeting VALUES (' 第 1 回', ' 富江'); INSERT INTO attendees_at_meeting VALUES (' 第 1 回', ' 深沢'); INSERT INTO attendees_at_meeting VALUES (' 第 1 回', ' 東'); INSERT INTO attendees_at_meeting VALUES (' 第 2 回', ' 富江'); INSERT INTO attendees_at_meeting VALUES (' 第 2 回', ' 安登'); INSERT INTO attendees_at_meeting VALUES (' 第 3 回', ' 東'); INSERT INTO attendees_at_meeting VALUES (' 第 3 回', ' 深沢'); INSERT INTO attendees_at_meeting VALUES (' 第 3 回', ' 安登'); ","9.2 テーブルに存在しないデータの抽出 91 SELECT meeting AS ' 会合', attendee AS ' 出席者' FROM attendees_at_meeting; このテーブルから、次のような思考で、出席しなかった人の一覧を作成する。（全回欠席 者はなし） 1. 全員が皆勤出席だった場合の一覧を作成（自己クロス結合） 2. 全員皆勤の場合のリストから、元の出席者リストに載っていない人だけを抽出 After ：欠席者一覧を表示 SELECT DISTINCT m1.meeting AS ' 会合', m2.attendee AS ' 欠席者' FROM attendees_at_meeting AS m1 CROSS JOIN attendees_at_meeting AS m2 WHERE NOT EXISTS ( SELECT * FROM attendees_at_meeting AS m3 WHERE m1.meeting = m3.meeting AND m2.attendee = m3.attendee ) ORDER BY m1.meeting; ","9.3 「すべての列が ⃝⃝」で絞り込み 92 Before attendees_at_meeting 会合 出席者 第 1 回 富江 第 1 回 深沢 第 1 回 東 第 2 回 富江 第 2 回 安登 第 3 回 東 第 3 回 深沢 第 3 回 安登 After 会合 欠席者 第 1 回 安登 第 2 回 深沢 第 2 回 東 第 3 回 富江 9.3 「すべての列が ⃝⃝」で絞り込み E”x´a‹m¯p˜l´e すべての教科が 50 点以上である生徒を検索 Before ：テストの点数一覧テーブルを作成・表示 CREATE TABLE test_scores( student_id INT, subject VARCHAR(10), score INT(100), PRIMARY KEY (student_id, subject) ","9.3 「すべての列が ⃝⃝」で絞り込み 93 ); INSERT INTO test_scores VALUES (100, ' 算数', 100); INSERT INTO test_scores VALUES (100, ' 国語', 80); INSERT INTO test_scores VALUES (100, ' 理科', 80); INSERT INTO test_scores VALUES (200, ' 算数', 80); INSERT INTO test_scores VALUES (200, ' 国語', 95); INSERT INTO test_scores VALUES (300, ' 算数', 40); INSERT INTO test_scores VALUES (300, ' 国語', 90); INSERT INTO test_scores VALUES (300, ' 社会', 55); INSERT INTO test_scores VALUES (400, ' 算数', 80); SELECT * FROM test_scores; 次のように考えて、すべての教科が 50 点以上（赤点回避）の生徒を抽出する。 「すべての教科が 50 点以上」⇐⇒「50 点未満の教科が 1 つも存在しない」 After ：すべての教科が 50 点以上の生徒を表示 SELECT DISTINCT student_id FROM test_scores AS t1 WHERE NOT EXISTS ( SELECT * FROM test_scores AS t2 WHERE t2.student_id = t1.student_id AND t2.score < 50 ); ","9.3 「すべての列が ⃝⃝」で絞り込み 94 Before test_scores student_id subject score 100 国語 80 100 理科 80 100 算数 100 200 国語 95 200 算数 80 300 国語 90 300 社会 55 300 算数 40 400 算数 80 After student_id 100 200 400 E”x´a‹m¯p˜l´e 合格点が教科により異なる場合の合格者抽出 引き続き成績表テーブルを使用し、今度は次の条件をともに満たす生徒を抽出する。 • 算数の点数が 80 点以上 • 国語の点数が 50 点以上 この条件を「すべて」というワードを使って言い換えると、 ある学生のすべての行について、 教科が算数ならば 80 点以上であり、教科が国語ならば 80 点以上である となる。これを SQL 文で表現すればよい。 ","9.3 「すべての列が ⃝⃝」で絞り込み 95 ただし、国語の成績データが存在しない 400 番の生徒は除外すること。 After ：算数 80 点以上かつ国語 80 点以上の生徒を表示 SELECT student_id FROM test_scores AS t1 WHERE subject IN (' 算数', ' 国語') AND NOT EXISTS ( SELECT * FROM test_scores AS t2 WHERE t2.student_id = t1.student_id AND 1 = CASE WHEN subject = ' 算数' AND score < 80 THEN 1 WHEN subject = ' 国語' AND score < 50 THEN 1 ELSE 0 END ) GROUP BY t1.student_id HAVING COUNT(*) = 2; ","9.4 「すべての列が ⃝⃝」で絞り込み 96 Before test_scores student_id subject score 100 国語 80 100 理科 80 100 算数 100 200 国語 95 200 算数 80 300 国語 90 300 社会 55 300 算数 40 400 算数 80 After student_id 100 200 9.4 「すべての列が ⃝⃝」で絞り込み E”x´a‹m¯p˜l´e 擬似配列テーブルからオール NULL の行を探す Before ：擬似配列テーブルの作成・表示 CREATE TABLE array( row_id CHAR(1), col1 INT, col2 INT, ","9.4 「すべての列が ⃝⃝」で絞り込み 97 col3 INT, col4 INT, col5 INT, col6 INT, col7 INT, col8 INT, col9 INT, col10 INT ); INSERT INTO array (row_id) VALUES ('A'); INSERT INTO array (row_id, col1) VALUES ('B', 3); INSERT INTO array VALUES ('C', 1, 1, 1, 1, 1, 1, 1, 1, 1, 1); INSERT INTO array (row_id, col2) VALUES ('D', 9); INSERT INTO array (row_id, col2, col3, col4, col7) VALUES ('E', 3, 1, 9, 9); SELECT * FROM array; After ：オール NULL の行を表示 SELECT * FROM array WHERE COALESCE(col1, col2, col3, col4, col5, col6, col7, col8, col9, col10) IS NULL; , → ","9.5 「少なくとも一つの列が ⃝⃝」で絞り込み 98 Before array row_id col1 col2 col3 col4 col5 col6 col7 col8 col9 col10 A B 3 C 1 1 1 1 1 1 1 1 1 1 D 9 E 3 1 9 9 After row_id col1 col2 col3 col4 col5 col6 col7 col8 col9 col10 A 9.5 「少なくとも一つの列が ⃝⃝」で絞り込み E”x´a‹m¯p˜l´e 擬似配列テーブルから少なくとも一つの列が 9 である行を探す After ：少なくとも一つの列が 9 である行の表示 SELECT * FROM array WHERE 9 IN (col1, col2, col3, col4, col5, col6, col7, col8, col9, col10); , → ","99 Before array row_id col1 col2 col3 col4 col5 col6 col7 col8 col9 col10 A B 3 C 1 1 1 1 1 1 1 1 1 1 D 9 E 3 1 9 9 After row_id col1 col2 col3 col4 col5 col6 col7 col8 col9 col10 D 9 E 3 1 9 9 10 HAVING 句と集合指向 E”x´a‹m¯p˜l´e 連番カラムの欠番の有無を判定する Before ：欠番のありそうな連番カラムをもつテーブルの作成・表示 CREATE TABLE sequence ( serial_number INT ); INSERT INTO sequence VALUES (1); INSERT INTO sequence VALUES (2); INSERT INTO sequence VALUES (3); ","100 INSERT INTO sequence VALUES (5); INSERT INTO sequence VALUES (6); INSERT INTO sequence VALUES (8); SELECT * FROM sequence; After ：欠番の有無を表示 SELECT CASE WHEN COUNT(*) = 0 THEN ' 空のテーブル' WHEN COUNT(*) <> MAX(serial_number) -MIN(serial_number) + 1 , → THEN ' あり' ELSE ' なし' END AS ' 欠番' FROM sequence; ","101 Before sequence serial_number 1 2 3 5 6 8 After 欠番 あり E”x´a‹m¯p˜l´e 最頻値を求める Before ：卒業生の収入を表すテーブルの作成・表示 CREATE TABLE graduates_income( name VARCHAR(20), income INT ); INSERT INTO graduates_income VALUES (' リリー', 400000); INSERT INTO graduates_income VALUES (' シオン', 30000); INSERT INTO graduates_income VALUES (' エル', 20000); INSERT INTO graduates_income VALUES (' クロエ', 20000); INSERT INTO graduates_income VALUES (' フローリア', 20000); INSERT INTO graduates_income VALUES (' アラン', 15000); ","102 INSERT INTO graduates_income VALUES (' レバン', 15000); INSERT INTO graduates_income VALUES (' ナタリア', 10000); INSERT INTO graduates_income VALUES (' パール', 10000); INSERT INTO graduates_income VALUES (' ニック', 10000); SELECT * FROM graduates_income; After ：最頻値の表示 SELECT income AS ' 収入', COUNT(*) AS ' 人数' FROM graduates_income GROUP BY income HAVING COUNT(*) >= ALL ( SELECT COUNT(*) FROM graduates_income GROUP BY income ); ","10.1 NULL を含まない集合を探す 103 Before graduates_income name income リリー 400000 シオン 30000 エル 20000 クロエ 20000 フローリア 20000 アラン 15000 レバン 15000 ナタリア 10000 パール 10000 ニック 10000 After 収入 人数 10000 3 20000 3 10.1 NULL を含まない集合を探す 10.1.1 COUNT(*) と COUNT(列名) の違い Before ：すべて NULL のテーブルの作成・表示 CREATE TABLE all_null( column_1 INT ); INSERT INTO all_null VALUES (NULL); INSERT INTO all_null VALUES (NULL); INSERT INTO all_null VALUES (NULL); ","10.1 NULL を含まない集合を探す 104 SELECT * FROM all_null; After ：COUNT(*) と COUNT(列名) の結果を表示 SELECT COUNT(*), COUNT(column_1) FROM all_null; Before all_null column_1 After COUNT(*) COUNT(column_1) 3 0 COUNT(*) は NULL を数えるが、COUNT(列名) は NULL を除外して数える。 この性質から、次のことがいえる。 列 A が NULL を含む ⇐⇒ COUNT(*) = COUNT(A) E”x´a‹m¯p˜l´e すべての学生がレポート提出済みの学部を検索 ","10.1 NULL を含まない集合を探す 105 Before ：学生のレポート提出日を記録したテーブル CREATE TABLE report_submission( student_id INT, department VARCHAR(10), submission_date DATE ); INSERT INTO report_submission VALUES (100, ' 理学部', '2018-10-10'); INSERT INTO report_submission VALUES (101, ' 理学部', '2018-09-22'); INSERT INTO report_submission (student_id, department) VALUES (102, ' 文学部'); INSERT INTO report_submission VALUES (103, ' 文学部', '2018-09-10'); INSERT INTO report_submission VALUES (200, ' 文学部', '2018-09-22'); INSERT INTO report_submission (student_id, department) VALUES (201, ' 工学部'); INSERT INTO report_submission VALUES (202, ' 経済学部', '2018-09-25'); SELECT * FROM report_submission; ","10.2 CASE 式による特性関数と組み合わせた集計・判定 106 After ：提出日に NULL を含まない学部を表示 SELECT department AS ' 全員提出済み' FROM report_submission GROUP BY department HAVING COUNT(*) = COUNT(submission_date); Before report_submission student_id department submission_date 100 理学部 2018-10-10 101 理学部 2018-09-22 102 文学部 103 文学部 2018-09-10 200 文学部 2018-09-22 201 工学部 202 経済学部 2018-09-25 After 全員提出済み 理学部 経済学部 10.2 CASE 式による特性関数と組み合わせた集計・判定 ","10.2 CASE 式による特性関数と組み合わせた集計・判定 107 E”x´a‹m¯p˜l´e クラスの 75% 以上が 80 点以上を取ったクラスを算出 生徒情報とそのテスト結果をまとめたテーブル CREATE TABLE test_results( student_id INT, class CHAR(1), sex CHAR(1), score INT(100) ); INSERT INTO test_results VALUES (001, 'A', ' 男', 100); INSERT INTO test_results VALUES (002, 'A', ' 女', 100); INSERT INTO test_results VALUES (003, 'A', ' 女', 49); INSERT INTO test_results VALUES (004, 'A', ' 男', 30); INSERT INTO test_results VALUES (005, 'B', ' 女', 100); INSERT INTO test_results VALUES (006, 'B', ' 男', 92); INSERT INTO test_results VALUES (007, 'B', ' 男', 80); INSERT INTO test_results VALUES (008, 'B', ' 男', 80); INSERT INTO test_results VALUES (009, 'B', ' 女', 10); INSERT INTO test_results VALUES (010, 'C', ' 男', 92); INSERT INTO test_results VALUES (011, 'C', ' 男', 80); INSERT INTO test_results VALUES (012, 'C', ' 女', 21); INSERT INTO test_results VALUES (013, 'D', ' 女', 100); INSERT INTO test_results VALUES (014, 'D', ' 女', 0); INSERT INTO test_results VALUES (015, 'D', ' 女', 0); SELECT * FROM test_results; クラスごとに生徒数（レコード数）をカウントし、その中の生徒について、 ","10.2 CASE 式による特性関数と組み合わせた集計・判定 108 • 80 点以上なら 1 人とカウント • 80 点未満なら 0 人とカウント した結果がそのクラスの全生徒数の 70% 以上となっているクラスを表示すればよい。 After ：クラスの 75% 以上が 80 点以上を取ったクラスを表示 SELECT class FROM test_results GROUP BY class HAVING COUNT(*) * 0.75 <= SUM( CASE WHEN score >= 80 THEN 1 ELSE 0 END ); ","10.2 CASE 式による特性関数と組み合わせた集計・判定 109 Before test_results student_id class sex score 1 A 男 100 2 A 女 100 3 A 女 49 4 A 男 30 5 B 女 100 6 B 男 92 7 B 男 80 8 B 男 80 9 B 女 10 10 C 男 92 11 C 男 80 12 C 女 21 13 D 女 100 14 D 女 0 15 D 女 0 After class B E”x´a‹m¯p˜l´e 50% 以上を取った生徒のうち、男子が女子よりも多いクラスを算出 ","10.2 CASE 式による特性関数と組み合わせた集計・判定 110 After ：50% 以上を取った生徒のうち、男子が女子よりも多いクラスを表示 SELECT class FROM test_results GROUP BY class HAVING SUM( CASE WHEN score >= 50 AND sex = ' 男' THEN 1 ELSE 0 END ) > SUM( CASE WHEN score >= 50 AND sex = ' 女' THEN 1 ELSE 0 END ); ","10.2 CASE 式による特性関数と組み合わせた集計・判定 111 Before test_results student_id class sex score 1 A 男 100 2 A 女 100 3 A 女 49 4 A 男 30 5 B 女 100 6 B 男 92 7 B 男 80 8 B 男 80 9 B 女 10 10 C 男 92 11 C 男 80 12 C 女 21 13 D 女 100 14 D 女 0 15 D 女 0 After class B C ","10.2 CASE 式による特性関数と組み合わせた集計・判定 112 E”x´a‹m¯p˜l´e 女子の平均点が男子の平均点よりも高いクラスを算出 After ：女子の平均点が男子の平均点よりも高いクラスを表示 SELECT class FROM test_results GROUP BY class HAVING AVG( CASE WHEN sex = ' 男' THEN score ELSE NULL END ) < AVG( CASE WHEN sex = ' 女' THEN score ELSE NULL END ); 0 での除算の結果は未定義である。 そのため、女子しかいない（男子が 0 人である）D クラスに関して、男子の平均点は未定 義でなくてはならない。 ","10.3 HAVING 句で「すべての」を扱う 113 この事情により、ELSE では 0 ではなく NULL を返すようにする。 Before test_results student_id class sex score 1 A 男 100 2 A 女 100 3 A 女 49 4 A 男 30 5 B 女 100 6 B 男 92 7 B 男 80 8 B 男 80 9 B 女 10 10 C 男 92 11 C 男 80 12 C 女 21 13 D 女 100 14 D 女 0 15 D 女 0 After class A 10.3 HAVING 句で「すべての」を扱う ","10.3 HAVING 句で「すべての」を扱う 114 E”x´a‹m¯p˜l´e 全員が待機中の部隊を探す Before ：隊員の状態と所属部隊を表すテーブル CREATE TABLE teams( member VARCHAR(10), team_id INT, status VARCHAR(3) ); INSERT INTO teams VALUES (' リリー', 1, ' 待機'); INSERT INTO teams VALUES (' シオン', 1, ' 出動中'); INSERT INTO teams VALUES (' クロエ', 1, ' 待機'); INSERT INTO teams VALUES (' アラン', 2, ' 出動中'); INSERT INTO teams VALUES (' エル', 2, ' 休暇'); INSERT INTO teams VALUES (' エルゼ', 3, ' 待機'); INSERT INTO teams VALUES (' ルーク', 3, ' 待機'); INSERT INTO teams VALUES (' ニック', 3, ' 待機'); INSERT INTO teams VALUES (' パール', 4, ' 待機'); INSERT INTO teams VALUES (' レバン', 5, ' 出動中'); INSERT INTO teams VALUES (' アーネスト', 5, ' 休暇'); INSERT INTO teams VALUES (' ゾーイ', 5, ' 待機'); SELECT * FROM teams; After ：全員が待機中（部隊の総人数 = 部隊の待機中人数）の部隊を表示 SELECT team_id FROM teams GROUP BY team_id ","10.3 HAVING 句で「すべての」を扱う 115 HAVING count(*) = SUM( CASE WHEN status = ' 待機' THEN 1 ELSE 0 END ); また、 全員の状態が「待機」なら、状態の最大値も最小値も「待機」にしかなりえない と考えて、次のように書くこともできる。 After ：全員が待機中の（状態は待機しかない）部隊を表示 SELECT team_id FROM teams GROUP BY team_id HAVING MAX(status) = ' 待機' AND MIN(status) = ' 待機'; ","10.4 値の重複を検出する 116 Before teams member team_id status リリー 1 待機 シオン 1 出動中 クロエ 1 待機 アラン 2 出動中 エル 2 休暇 エルゼ 3 待機 ルーク 3 待機 ニック 3 待機 パール 4 待機 レバン 5 出動中 アーネスト 5 休暇 ゾーイ 5 待機 After team_id 3 4 10.4 値の重複を検出する E”x´a‹m¯p˜l´e 資材が搬入されすぎて余っているであろう現場を特定する ","10.4 値の重複を検出する 117 Before ：拠点ごとの資材搬入履歴を表すテーブル CREATE TABLE carry_in_history( stronghold VARCHAR(10), carry_in_date DATE, material VARCHAR(20) ); INSERT INTO carry_in_history VALUES (' 東京', '2018-4-01', ' スズ'); INSERT INTO carry_in_history VALUES (' 東京', '2018-4-12', ' 亜鉛'); INSERT INTO carry_in_history VALUES (' 東京', '2018-5-17', ' アルミニウム'); INSERT INTO carry_in_history VALUES (' 東京', '2018-5-20', ' 亜鉛'); INSERT INTO carry_in_history VALUES (' 大阪', '2018-4-20', ' 銅'); INSERT INTO carry_in_history VALUES (' 大阪', '2018-4-22', ' ニッケル'); INSERT INTO carry_in_history VALUES (' 大阪', '2018-4-29', ' 鉛'); INSERT INTO carry_in_history VALUES (' 名古屋', '2018-3-15', ' チタン'); INSERT INTO carry_in_history VALUES (' 名古屋', '2018-4-01', ' 炭素鋼'); INSERT INTO carry_in_history VALUES (' 名古屋', '2018-4-24', ' 炭素鋼'); INSERT INTO carry_in_history VALUES (' 名古屋', '2018-5-02', ' マグネシウム'); INSERT INTO carry_in_history VALUES (' 名古屋', '2018-5-10', ' チタン'); ","10.4 値の重複を検出する 118 INSERT INTO carry_in_history VALUES (' 福岡', '2018-5-10', ' 亜鉛'); INSERT INTO carry_in_history VALUES (' 福岡', '2018-5-28', ' スズ'); SELECT * FROM carry_in_history; After ：搬入された資材が重複している拠点を表示 SELECT stronghold FROM carry_in_history GROUP BY stronghold HAVING COUNT(material) <> COUNT(DISTINCT material); ","10.5 複数要件を満たすものを見つけ出す 119 Before carry_in_history stronghold carry_in_date material 東京 2018-04-01 スズ 東京 2018-04-12 亜鉛 東京 2018-05-17 アルミニウム 東京 2018-05-20 亜鉛 大阪 2018-04-20 銅 大阪 2018-04-22 ニッケル 大阪 2018-04-29 鉛 名古屋 2018-03-15 チタン 名古屋 2018-04-01 炭素鋼 名古屋 2018-04-24 炭素鋼 名古屋 2018-05-02 マグネシウム 名古屋 2018-05-10 チタン 福岡 2018-05-10 亜鉛 福岡 2018-05-28 スズ After stronghold 名古屋 東京 10.5 複数要件を満たすものを見つけ出す ","10.5 複数要件を満たすものを見つけ出す 120 E”x´a‹m¯p˜l´e 指定したすべての商品を置いている店舗を探す After ：男性がよく買う商品一覧テーブルと店舗ごとの在庫テーブル CREATE TABLE items ( item VARCHAR(10) ); INSERT INTO items VALUES (' ビール'); INSERT INTO items VALUES (' 紙オムツ'); INSERT INTO items VALUES (' 自転車'); CREATE TABLE shop_stock_items( shop VARCHAR(10), item VARCHAR(10) ); INSERT INTO shop_stock_items VALUES (' 仙台', ' ビール'); INSERT INTO shop_stock_items VALUES (' 仙台', ' 紙オムツ'); INSERT INTO shop_stock_items VALUES (' 仙台', ' 自転車'); INSERT INTO shop_stock_items VALUES (' 仙台', ' カーテン'); INSERT INTO shop_stock_items VALUES (' 東京', ' ビール'); INSERT INTO shop_stock_items VALUES (' 東京', ' 紙オムツ'); INSERT INTO shop_stock_items VALUES (' 東京', ' 自転車'); INSERT INTO shop_stock_items VALUES (' 大阪', ' テレビ'); INSERT INTO shop_stock_items VALUES (' 大阪', ' 紙オムツ'); INSERT INTO shop_stock_items VALUES (' 大阪', ' 自転車'); SELECT * FROM items; SELECT * FROM shop_stock_items; ","10.5 複数要件を満たすものを見つけ出す 121 After ：items テーブルの全商品をすべて置いている店舗を表示 SELECT s.shop FROM shop_stock_items AS s INNER JOIN items AS i USING(item) GROUP BY s.shop HAVING COUNT(s.item) = ( SELECT COUNT(item) FROM items ); この SQL 文は、内部結合により、items テーブルにはない商品の行は捨てられることを 利用している。 仙台店のカーテンは排除されたため、items テーブルの商品数と一致して仙台店も表示さ ","10.5 複数要件を満たすものを見つけ出す 122 れることになる。 Before items item ビール 紙オムツ 自転車 Before shop_stock_items shop item 仙台 ビール 仙台 紙オムツ 仙台 自転車 仙台 カーテン 東京 ビール 東京 紙オムツ 東京 自転車 大阪 テレビ 大阪 紙オムツ 大阪 自転車 After shop 仙台 東京 E”x´a‹m¯p˜l´e 指定したすべての商品だけを置いている店舗を探す ","10.5 複数要件を満たすものを見つけ出す 123 商品テーブルと店舗ごとの在庫テーブルの左外部結合を表示 SELECT s.shop, s.item AS 's.item', i.item AS 'i.item' FROM shop_stock_items AS s LEFT OUTER JOIN items AS i USING(item) ORDER BY s.shop; shop s.item i.item 仙台 自転車 自転車 仙台 ビール ビール 仙台 カーテン 仙台 紙オムツ 紙オムツ 大阪 テレビ 大阪 紙オムツ 紙オムツ 大阪 自転車 自転車 東京 紙オムツ 紙オムツ 東京 自転車 自転車 東京 ビール ビール COUNT(i.item) では NULL はカウントされないから、 items テーブルにない商品を置いている店舗では、s.item の数と i.item の数がズレる ことになる。 よって、 COUNT(s.item) = COUNT(i.item) という条件で絞り込めば要件を満たしそうな気がするが、 この条件では、「items テーブルにある商品の一部しか置いていない店舗」も表示されてし ","10.5 複数要件を満たすものを見つけ出す 124 まう。 どちらも items テーブルの要素数に一致する、という条件を与える必要がある。 After ：ビール・紙オムツ・自転車だけを置いている店舗を表示 SELECT s.shop FROM shop_stock_items AS s LEFT OUTER JOIN items AS i USING(item) GROUP BY s.shop HAVING COUNT(s.item) = (SELECT COUNT(item) FROM items) AND COUNT(i.item) = (SELECT COUNT(item) FROM items); Before items item ビール 紙オムツ 自転車 Before shop_stock_items shop item 仙台 ビール 仙台 紙オムツ 仙台 自転車 仙台 カーテン 東京 ビール 東京 紙オムツ 東京 自転車 大阪 テレビ 大阪 紙オムツ 大阪 自転車 ","125 After shop 東京 11 SQL と集合演算 11.1 集合の相等性判定 Before ：等しい二つのテーブル CREATE TABLE matrix_A( row_key CHAR(1), column_1 INTEGER, column_2 INTEGER, column_3 INTEGER ); INSERT INTO matrix_A VALUES ('A', 2, 3, 4); INSERT INTO matrix_A VALUES ('B', 0, 7, 9); INSERT INTO matrix_A VALUES ('C', 5, 1, 6); CREATE TABLE matrix_B( row_key CHAR(1), column_1 INTEGER, column_2 INTEGER, column_3 INTEGER ); INSERT INTO matrix_B VALUES ('A', 2, 3, 4); INSERT INTO matrix_B VALUES ('B', 0, 7, 9); ","11.1 集合の相等性判定 126 INSERT INTO matrix_B VALUES ('C', 5, 1, 6); SELECT * FROM matrix_A; SELECT * FROM matrix_B; 集合 A と集合 B が等しければ、その和集合は集合 A 及び B と一致する（当然、行数も一 致）。 逆に、集合 A と集合 B が数行異なれば、和集合の行数はその異なる行数分増えることに なる。 After ：テーブルが等しいかどうかを表示 SELECT CASE WHEN COUNT(*) = (SELECT COUNT(*) FROM matrix_A) AND COUNT(*) = (SELECT COUNT(*) FROM matrix_B) THEN ' 等しい' ELSE ' 等しくない' END AS 'A と B は' FROM ( SELECT * FROM matrix_A UNION SELECT * FROM matrix_B ) AS sum_set; ","11.2 等しい部分集合の検出 127 Before matrix_A row_key column_1 column_2 column_3 A 2 3 4 B 0 7 9 C 5 1 6 Before matrix_B row_key column_1 column_2 column_3 A 2 3 4 B 0 7 9 C 5 1 6 After A と B は 等しい 11.2 等しい部分集合の検出 E”x´a‹m¯p˜l´e 取扱商品がまったく同じ業者を見つける ","11.2 等しい部分集合の検出 128 Before ：業者が取り扱っている部品の一覧テーブル CREATE TABLE parts_suppliers( supplier CHAR(1), part VARCHAR(10) ); INSERT INTO parts_suppliers VALUES ('A', ' ボルト'); INSERT INTO parts_suppliers VALUES ('A', ' ナット'); INSERT INTO parts_suppliers VALUES ('A', ' パイプ'); INSERT INTO parts_suppliers VALUES ('B', ' ボルト'); INSERT INTO parts_suppliers VALUES ('B', ' パイプ'); INSERT INTO parts_suppliers VALUES ('C', ' ボルト'); INSERT INTO parts_suppliers VALUES ('C', ' ナット'); INSERT INTO parts_suppliers VALUES ('C', ' パイプ'); INSERT INTO parts_suppliers VALUES ('D', ' ボルト'); INSERT INTO parts_suppliers VALUES ('D', ' パイプ'); INSERT INTO parts_suppliers VALUES ('E', ' ヒューズ'); INSERT INTO parts_suppliers VALUES ('E', ' ナット'); INSERT INTO parts_suppliers VALUES ('E', ' パイプ'); INSERT INTO parts_suppliers VALUES ('F', ' ヒューズ'); SELECT * FROM parts_suppliers; 業者のペア（すべての組合せ）一覧を表示 SELECT ps1.supplier AS ' 業者 1', ps2.supplier AS ' 業者 2' FROM parts_suppliers AS ps1 ","11.2 等しい部分集合の検出 129 INNER JOIN parts_suppliers AS ps2 WHERE ps1.supplier < ps2.supplier GROUP BY ps1.supplier, ps2.supplier ORDER BY ps1.supplier, ps2.supplier 業者 1 業者 2 A B A C A D A E A F B C B D B E B F C D C E C F D E D F E F 上のテーブルに、次の条件を与える。 • どちらの業者も同じ種類の部品を扱っている（WHERE 句に追加） • どちらの業者も同数の部品を扱っている（HAVING 句として追加） ","11.2 等しい部分集合の検出 130 After ：取扱商品がまったく同じ供給業者のペアを表示 SELECT ps1.supplier AS ' 業者 1', ps2.supplier AS ' 業者 2' FROM parts_suppliers AS ps1 INNER JOIN parts_suppliers AS ps2 WHERE ps1.supplier < ps2.supplier AND ps1.part = ps2.part GROUP BY ps1.supplier, ps2.supplier HAVING COUNT(*) = ( SELECT COUNT(*) FROM parts_suppliers AS ps3 WHERE ps1.supplier = ps3.supplier ) AND COUNT(*) = ( SELECT COUNT(*) FROM parts_suppliers AS ps4 WHERE ps2.supplier = ps4.supplier ) ORDER BY ps1.supplier, ps2.supplier; ","11.2 等しい部分集合の検出 131 Before parts_suppliers supplier part A ボルト A ナット A パイプ B ボルト B パイプ C ボルト C ナット C パイプ D ボルト D パイプ E ヒューズ E ナット E パイプ F ヒューズ After 業者 1 業者 2 A C B D ","132 12 SQL と数列 12.1 連番の作成 0～9 の数字一覧 CREATE TABLE digits ( digit INTEGER(1) ); INSERT INTO digits VALUES (0); INSERT INTO digits VALUES (1); INSERT INTO digits VALUES (2); INSERT INTO digits VALUES (3); INSERT INTO digits VALUES (4); INSERT INTO digits VALUES (5); INSERT INTO digits VALUES (6); INSERT INTO digits VALUES (7); INSERT INTO digits VALUES (8); INSERT INTO digits VALUES (9); SELECT * FROM digits; ","12.1 連番の作成 133 digit 0 1 2 3 4 5 6 7 8 9 00～99 までの数は、0～9 の数から 2 つを選んで並べた重複順列と考えられる。 （00・11・··· ・88・99）を作成するには、「重複」順列でなければならない。） 0～99 の数字一覧を表示 SELECT D1.digit + (D2.digit * 10) AS sequence FROM digits AS D1 CROSS JOIN digits AS D2 ORDER BY sequence; 0～999 の数字一覧を表示 SELECT D1.digit + (D2.digit * 10) + (D3.digit * 100) ","12.1 連番の作成 134 AS sequence FROM digits AS D1 CROSS JOIN digits AS D2 CROSS JOIN digits AS D3 ORDER BY sequence; この連番リストを、再利用できるようにビューとして定義しておく。 0～999 の数字一覧リストをビューとして定義 CREATE VIEW sequence_list AS SELECT D1.digit + (D2.digit * 10) + (D3.digit * 100) AS sequence FROM digits AS D1 CROSS JOIN digits AS D2 CROSS JOIN digits AS D3 ORDER BY sequence; この連番リストビューは、次のようにして使う。 322～333 の連番を表示 SELECT sequence FROM sequence_list WHERE sequence BETWEEN 322 AND 333; ","12.2 全ての欠番を見つける 135 sequence 322 323 324 325 326 327 328 329 330 331 332 333 12.2 全ての欠番を見つける Before ：欠番のありそうな連番リスト CREATE TABLE missing_sequence( sequence INTEGER ); INSERT INTO missing_sequence VALUES (1); INSERT INTO missing_sequence VALUES (2); INSERT INTO missing_sequence VALUES (4); INSERT INTO missing_sequence VALUES (5); INSERT INTO missing_sequence VALUES (6); INSERT INTO missing_sequence VALUES (7); INSERT INTO missing_sequence VALUES (8); INSERT INTO missing_sequence VALUES (11); ","12.2 全ての欠番を見つける 136 INSERT INTO missing_sequence VALUES (12); SELECT * FROM missing_sequence; After ：欠番を見つけて表示（連番の範囲は自動検出） SELECT sequence AS ' 欠番' FROM sequence_list WHERE sequence BETWEEN (SELECT MIN(sequence) FROM missing_sequence) AND (SELECT MAX(sequence) FROM missing_sequence) AND sequence NOT IN ( SELECT sequence FROM missing_sequence ); ","12.2 全ての欠番を見つける 137 Before missing_sequence sequence 1 2 4 5 6 7 8 11 12 After 欠番 3 9 10 E”x´a‹m¯p˜l´e 3 人は並んで座れるか（一列に並ぶ座席） Before ：座席の空席状況を表すテーブル CREATE TABLE seats( seat_id INTEGER, status CHAR(1) ); INSERT INTO seats VALUES (1, ' 占'); INSERT INTO seats VALUES (2, ' 占'); INSERT INTO seats VALUES (3, ' 空'); ","12.2 全ての欠番を見つける 138 INSERT INTO seats VALUES (4, ' 空'); INSERT INTO seats VALUES (5, ' 空'); INSERT INTO seats VALUES (6, ' 占'); INSERT INTO seats VALUES (7, ' 空'); INSERT INTO seats VALUES (8, ' 空'); INSERT INTO seats VALUES (9, ' 空'); INSERT INTO seats VALUES (10, ' 空'); INSERT INTO seats VALUES (11, ' 空'); INSERT INTO seats VALUES (12, ' 占'); INSERT INTO seats VALUES (13, ' 占'); INSERT INTO seats VALUES (14, ' 空'); INSERT INTO seats VALUES (15, ' 空'); SELECT * FROM seats; 全ての連続する 3 つの座席を一覧にする SELECT s1.seat_id AS start, '～', s2.seat_id AS end FROM seats AS s1 INNER JOIN seats AS s2 ON s2.seat_id = s1.seat_id + (3 -1) ","12.2 全ての欠番を見つける 139 start ～ end 1 ～ 3 2 ～ 4 3 ～ 5 4 ～ 6 5 ～ 7 6 ～ 8 7 ～ 9 8 ～ 10 9 ～ 11 10 ～ 12 11 ～ 13 12 ～ 14 13 ～ 15 この中から、すべての座席が「空」である連続座席だけを抜き出せばよい。 言い換えると、 「空」以外の座席（レコード）が存在しない組 だけを抜き出せばよいことになる。 After ：一列に並ぶ座席から、連続する 3 個の空席を抽出して表示 SELECT s1.seat_id AS start, '～', s2.seat_id AS end FROM seats AS s1 INNER JOIN seats AS s2 ","12.2 全ての欠番を見つける 140 ON s2.seat_id = s1.seat_id + (3 -1) WHERE NOT EXISTS ( SELECT * FROM seats AS s3 WHERE s3.seat_id BETWEEN s1.seat_id AND s2.seat_id AND s3.status <> ' 空' ); Before seats seat_id status 1 占 2 占 3 空 4 空 5 空 6 占 7 空 8 空 9 空 10 空 11 空 12 占 13 占 14 空 15 空 After start ～ end 3 ～ 5 7 ～ 9 8 ～ 10 9 ～ 11 ","12.2 全ての欠番を見つける 141 E”x´a‹m¯p˜l´e 3 人は並んで座れるか（複数列に並ぶ座席） Before ：各列の座席の空席状況を表すテーブル CREATE TABLE multirow_seats( seat_id INTEGER, line_id CHAR(1), status CHAR(1) ); INSERT INTO multirow_seats VALUES (1, 'A', ' 占'); INSERT INTO multirow_seats VALUES (2, 'A', ' 占'); INSERT INTO multirow_seats VALUES (3, 'A', ' 空'); INSERT INTO multirow_seats VALUES (4, 'A', ' 空'); INSERT INTO multirow_seats VALUES (5, 'A', ' 空'); INSERT INTO multirow_seats VALUES (6, 'B', ' 占'); INSERT INTO multirow_seats VALUES (7, 'B', ' 占'); INSERT INTO multirow_seats VALUES (8, 'B', ' 空'); INSERT INTO multirow_seats VALUES (9, 'B', ' 空'); INSERT INTO multirow_seats VALUES (10, 'B', ' 空'); INSERT INTO multirow_seats VALUES (11, 'C', ' 空'); INSERT INTO multirow_seats VALUES (12, 'C', ' 空'); INSERT INTO multirow_seats VALUES (13, 'C', ' 空'); INSERT INTO multirow_seats VALUES (14, 'C', ' 占'); INSERT INTO multirow_seats VALUES (15, 'C', ' 空'); SELECT * FROM multirow_seats; ","12.2 全ての欠番を見つける 142 連続する 3 座席のうち、 • 空席がある • 違う座席に位置する座席がある の少なくとも一つに該当するものは要件を満たさない。 空席でない or 同じ列でないものが一つも存在しなければよい。 After ：複数列の座席から、連続する 3 個の空席を抽出して表示 SELECT s1.seat_id AS start, '～', s2.seat_id AS end FROM multirow_seats AS s1 INNER JOIN multirow_seats AS s2 ON s2.seat_id = s1.seat_id + (3 -1) WHERE NOT EXISTS ( SELECT * FROM multirow_seats AS s3 WHERE s3.seat_id BETWEEN s1.seat_id AND s2.seat_id AND ( s3.status <> ' 空' OR s3.line_id <> s1.line_id ) ); ","143 Before multirow_seats seat_id line_id status 1 A 占 2 A 占 3 A 空 4 A 空 5 A 空 6 B 占 7 B 占 8 B 空 9 B 空 10 B 空 11 C 空 12 C 空 13 C 空 14 C 占 15 C 空 After start ～ end 3 ～ 5 8 ～ 10 11 ～ 13 第 IV 部 リレーショナルモデルと関係代数 リレーショナルモデルに基づいて作成されたデータベースが、リレーショナルデータベー スである。 SQL との用語の対応は、次のようになる。 ","144 モデル 意味 SQL 集合論 リレーション テーブル （関係） 属性 属性名と型から構成される 列 組 行 和 リレーション同士の足し算 UNION 和集合 差 リレーション同士の引き算 EXCEPT 差集合 交わり リレーション同士の共通部分 INTERSECT 積集合 直積 リレーション同士の総当たりの組合せ CROSS JOIN 選択（制限） 組の抽出 WHERE 射影 属性の抽出 SELECT 結合 直積の結果から、 INNER JOIN 結合条件を満たすような組だけを選択 （INNER INNER JOIN） 第 V 部 正規化 E”x´a‹m¯p˜l´e 注文データテーブルの正規化 注文データテーブル（仮） 注文番号 注文日 注文者氏名 注文者連絡先 注文内容 1 2021-01-01 富江冴月 080-xxxx 0001 商品 A1 個、0002 商品 B 10 個 2 2021-02-01 深沢雪 090-xxxx 0001 商品 A2 個、0002 商品 B3 個 3 2021-02-05 富江冴月 080-xxxx 0001 商品 A3 個、0003 商品 C1 個 「注文内容」カラムには、 • 商品コード • 商品名 ","145 • 個数 が詰め込まれている。 1 つのセル内に 1 つの値のみを格納できるようにカラムを分割して、 行数を増やし、横に並んでいる複数商品が縦に並ぶようにする。（第 1 正規化の第 1 段階） 注文データテーブル（第 1 正規化第 1 段階） 注文番号 注文日 注文者氏名 注文者連絡先 商品コード 商品名 注文個数 1 2021-01-01 富江冴月 080-xxxx 0001 商品 A 1 1 2021-01-01 富江冴月 080-xxxx 0002 商品 B 10 2 2021-02-01 深沢雪 090-xxxx 0001 商品 A 2 2 2021-02-01 深沢雪 090-xxxx 0002 商品 B 3 3 2021-02-05 富江冴月 080-xxxx 0001 商品 A 3 3 2021-02-05 富江冴月 080-xxxx 0003 商品 C 1 上のテーブルでは、注文する商品種類数に応じて、一回の注文データが複数行に分かれて しまい、日付や注文者情報が重複する行ができてしまっている。 このような重複をなくすため、テーブルを分割する。（第 1 正規化の第 2 段階） 注文データ（第 1 正規化第 2 段階） 注文履歴テーブル 注文番号 ⋆ 注文日 注文者氏名 注文者連絡先 1 2021-01-01 富江冴月 080-xxxx 2 2021-02-01 深沢雪 090-xxxx 3 2021-02-05 富江冴月 080-xxxx ","146 注文データ（第 1 正規化第 2 段階） 注文商品テーブル 注文番号 ⋆ 商品コード ⋆ 商品名 注文個数 1 0001 商品 A 1 1 0002 商品 B 10 2 0001 商品 A 2 2 0002 商品 B 3 3 0001 商品 A 3 3 0003 商品 C 1 プライマリーキーを ⋆ で示している。 注文商品テーブルに着目すると、 • 注文個数は注文番号と商品コードが分かれば特定できる • 商品名は商品コードが分かれば特定できる プライマリーキー（注文番号&商品コード）によって特定される列だけを残し、 商品名は商品コードをプライマリーキーとする別テーブルに格納することにする。（第 2 正規化） 注文データ（第 2 正規化） 注文履歴テーブル 注文番号 ⋆ 注文日 注文者氏名 注文者連絡先 1 2021-01-01 富江冴月 080-xxxx 2 2021-02-01 深沢雪 090-xxxx 3 2021-02-05 富江冴月 080-xxxx ","147 注文データ（第 2 正規化） 注文商品テーブル 注文番号 ⋆ 商品コード ⋆ 注文個数 1 0001 1 1 0002 10 2 0001 2 2 0002 3 3 0001 3 3 0003 1 注文データ（第 2 正規化） 商品テーブル 商品コード ⋆ 商品名 0001 商品 A 0002 商品 B 0003 商品 C 注文履歴テーブルに着目すると、同じ人が何度も注文していることで、注文者名と連絡先 が一致する行が複数ある。 注文者名が分かれば注文者の連絡先も決まるため、これを別テーブルに分離する。（第 3 正規化） ただし、同姓同名の人の存在を考慮して、新しく作る顧客テーブルのプライマリーキーは ","148 別途作成することにする。 注文データ（第 3 正規化） 注文履歴テーブル 注文番号 ⋆ 注文日 顧客番号 1 2021-01-01 1 2 2021-02-01 2 3 2021-02-05 1 注文データ（第 3 正規化） 顧客テーブル 顧客番号 ⋆ 氏名 連絡先 1 富江冴月 080-xxxx 2 深沢雪 090-xxxx 注文データ（第 3 正規化） 注文商品テーブル 注文番号 ⋆ 商品コード ⋆ 注文個数 1 0001 1 1 0002 10 2 0001 2 2 0002 3 3 0001 3 3 0003 1 ","149 注文データ（第 3 正規化） 商品テーブル 商品コード ⋆ 商品名 0001 商品 A 0002 商品 B 0003 商品 C 以上の過程をまとめると、 1. 第一正規化では、 1 つのセル内に 1 つの値のみを格納できるようにカラムを分割し、 それによって生じた重複をなくすためにテーブル分割する 2. 第二正規化では、必要なプライマリーキーごとにテーブルを分割する 3. 第三正規化では、プライマリーキー以外の重複する情報を別テーブルに分離する 1 つのデータを 1 箇所に記録するようなデータ構造にするために、このような正規化が行 われる。 第 VI 部 トランザクション "]